<!DOCTYPE html>
<html lang="zh">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <link rel="stylesheet" type="text/css" href="http://yszheda.github.io/blog/theme/css/elegant.prod.9e9d5ce754.css" media="screen">
        <link rel="stylesheet" type="text/css" href="http://yszheda.github.io/blog/theme/css/custom.css" media="screen">

        <link rel="dns-prefetch" href="//fonts.googleapis.com">
        <link rel="preconnect" href="https://fonts.gstatic.com/" crossorigin>

        <meta name="author" content="Galoisplusplus" />

        <meta property="og:type" content="article" />
        <meta name="twitter:card" content="summary">

<meta name="keywords" content="tech, CS, Branch Prediction, SimpleScalar, Computer Architecture, 分支预测, 体系结构, 计算机体系, tech, " />

<meta property="og:title" content="Learn branch prediction from SimpleScalar source (1) "/>
<meta property="og:url" content="http://yszheda.github.io/blog/2013/07/22/20130722-learn-branch-predictor-from-simplescalar-source-1.html" />
<meta property="og:description" content="作为一名CSer，最好的学习方式之一无疑是tracing code，看源代码—— 不知你此时是否与我一样想起了Linus那句名言「talk is cheap, show me the fucking code!」? 可是对计 …" />
<meta property="og:site_name" content="Galoisplusplus" />
<meta property="og:article:author" content="Galoisplusplus" />
<meta property="og:article:published_time" content="2013-07-22T17:10:00+08:00" />
<meta name="twitter:title" content="Learn branch prediction from SimpleScalar source (1) ">
<meta name="twitter:description" content="作为一名CSer，最好的学习方式之一无疑是tracing code，看源代码—— 不知你此时是否与我一样想起了Linus那句名言「talk is cheap, show me the fucking code!」? 可是对计 …">

        <title>Learn branch prediction from SimpleScalar source (1)  · Galoisplusplus
</title>



        <!-- MathJax for LaTeX support -->
        <script type="text/x-mathjax-config">
          MathJax.Hub.Config({
            tex2jax: {
              inlineMath: [['$', '$'], ['\\(', '\\)']],
              displayMath: [['$$', '$$'], ['\\[', '\\]']],
              processEscapes: true,
              processEnvironments: true
            }
          });
        </script>
        <script async src="https://cdn.jsdelivr.net/npm/mathjax@2.7.9/MathJax.js?config=TeX-MML-AM_CHTML"></script>
    </head>
    <body>
        <div id="content">
            <div class="navbar navbar-static-top">
                <div class="navbar-inner">
                    <div class="container-fluid">
                        <a class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
                            <span class="icon-bar"></span>
                            <span class="icon-bar"></span>
                            <span class="icon-bar"></span>
                        </a>
                        <a class="brand" href="http://yszheda.github.io/blog/"><span class=site-name>Galoisplusplus</span></a>
                        <div class="nav-collapse collapse">
                            <ul class="nav pull-right top-menu">
                                <li >
                                    <a href=
                                       http://yszheda.github.io/blog
                                    >Home</a>
                                </li>
                                <li ><a href="http://yszheda.github.io/blog/categories.html">Categories</a></li>
                                <li ><a href="http://yszheda.github.io/blog/tags.html">Tags</a></li>
                                <li ><a href="http://yszheda.github.io/blog/archives.html">Archives</a></li>
                                <li><form class="navbar-search" action="http://yszheda.github.io/blog/search.html" onsubmit="return validateForm(this.elements['q'].value);"> <input type="text" class="search-query" placeholder="Search" name="q" id="tipue_search_input"></form></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
            <div class="container-fluid">
                <div class="row-fluid">
                    <div class="span1"></div>
                    <div class="span10">
<article itemscope>
<div class="row-fluid">
    <header class="page-header span10 offset2">
        <h1>
            <a href="http://yszheda.github.io/blog/2013/07/22/20130722-learn-branch-predictor-from-simplescalar-source-1.html">
                Learn branch prediction from SimpleScalar source (1)
            </a>
        </h1>
    </header>
</div>

<div class="row-fluid">
        <div class="span8 offset2 article-content">
            
            <p>作为一名CSer，最好的学习方式之一无疑是tracing code，看源代码——
不知你此时是否与我一样想起了Linus那句名言「talk is cheap, show me the <del>fucking</del> code!」?
可是对计算机体系结构来说，很多技术直接是由硬件实现的，因而也被蒙上一层神秘的面纱。
好在还有一些模拟器（simulator）软件，例如SimpleScalar(http://www.simplescalar.com/)就是这样一套模拟处理器性能的工具集。
之前我有幸通过做一些project接触SimpleScalar并读了一些cache技术的源代码。
在此我借SimpleScalar源代码为工具介绍branch prediction技术，
也算是对几个月前折腾时光的一种整理吧~</p>
<p>首先先简单介绍下branch prediction是做神马。
branch是instruction sets里面十分常见的一类指令。
一般可以分为：</p>
<ul>
<li>
<p>conditional branch：只在某条件下才跳转。例如<code>MIPS</code>里的<code>beq</code>/<code>bne</code>等。</p>
</li>
<li>
<p>unconditional branch（或简称jump）: 无条件跳转。例如<code>MIPS</code>里的<code>j</code>/<code>jr</code>等。</p>
</li>
<li>
<p>还有一类特殊的跳转指令，就是function call和return。</p>
</li>
</ul>
<!-- more -->

<p>这类指令在一般程序里的出现频率是很高的，据说平均每4至5条指令就会出现一条branch指令，这也是为什么大多数<code>basic block</code>都很短的原因。
不幸的是，在我们CPU的pipeline中我们常常要在后面的stage才能得到branch的结果。
显然在fetch到branch指令与resolve出结果之间「漫长」的clock cycle中，我们希望能同时处理之后的指令。
那么在resolve之前我们怎么知道branch之后的指令是什么？
这时候我们就需要branch prediction了。</p>
<p>简单地说，branch prediction要预测的主要是两件事：</p>
<ul>
<li>
<p>direction：conditional branch是taken还是not taken？</p>
</li>
<li>
<p>target：branch指令要跳转的目的地是哪里？除了conditional branch，这也包括function pointer和indirect jump，例如<code>MPIS</code>中的<code>jr</code>指令就需要在计算出<code>r31</code>的值后才知道跳转目标。</p>
</li>
</ul>
<p>针对预测direction的有branch direction predictor；
针对预测target的有一般的BTB(Branch Target Buffer)，
还有针对call和return的RAS(Return Address Stack)。
在SimpleScalar中，branch predictor被定义为以下structure：</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="cm">/* branch predictor def */</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">bpred_t</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">enum</span><span class="w"> </span><span class="n">bpred_class</span><span class="w"> </span><span class="n">class</span><span class="p">;</span><span class="w">   </span><span class="cm">/* type of predictor */</span>
<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">bpred_dir_t</span><span class="w"> </span><span class="o">*</span><span class="n">bimod</span><span class="p">;</span><span class="w">    </span><span class="cm">/* first direction predictor */</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">bpred_dir_t</span><span class="w"> </span><span class="o">*</span><span class="n">twolev</span><span class="p">;</span><span class="w">   </span><span class="cm">/* second direction predictor */</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">bpred_dir_t</span><span class="w"> </span><span class="o">*</span><span class="n">meta</span><span class="p">;</span><span class="w">     </span><span class="cm">/* meta predictor */</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="n">dirpred</span><span class="p">;</span>

<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">sets</span><span class="p">;</span><span class="w">           </span><span class="cm">/* num BTB sets */</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">assoc</span><span class="p">;</span><span class="w">          </span><span class="cm">/* BTB associativity */</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">bpred_btb_ent_t</span><span class="w"> </span><span class="o">*</span><span class="n">btb_data</span><span class="p">;</span><span class="w"> </span><span class="cm">/* BTB addr-prediction table */</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="n">btb</span><span class="p">;</span>

<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">size</span><span class="p">;</span><span class="w">           </span><span class="cm">/* return-address stack size */</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">tos</span><span class="p">;</span><span class="w">            </span><span class="cm">/* top-of-stack */</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">bpred_btb_ent_t</span><span class="w"> </span><span class="o">*</span><span class="n">stack</span><span class="p">;</span><span class="w"> </span><span class="cm">/* return-address stack */</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="n">retstack</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// 以下省略模拟用的状态计数器</span>
<span class="p">}</span>
</code></pre></div></td></tr></table></div>

<p>以下我将针对各部分进行介绍。</p>
<h2 id="branch-direction-predictor">branch direction predictor</h2>
<p>在SimpleScalar中定义了如下的direction predictor类别：</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span>
<span class="normal">4</span>
<span class="normal">5</span>
<span class="normal">6</span>
<span class="normal">7</span>
<span class="normal">8</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="cm">/* branch predictor types */</span>
<span class="k">enum</span><span class="w"> </span><span class="n">bpred_class</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">BPredComb</span><span class="p">,</span><span class="w">            </span><span class="cm">/* combined predictor (McFarling) */</span>
<span class="w">  </span><span class="n">BPred2Level</span><span class="p">,</span><span class="w">          </span><span class="cm">/* 2-level correlating pred w/2-bit counters */</span>
<span class="w">  </span><span class="n">BPred2bit</span><span class="p">,</span><span class="w">            </span><span class="cm">/* 2-bit saturating cntr pred (dir mapped) */</span>
<span class="w">  </span><span class="n">BPredTaken</span><span class="p">,</span><span class="w">           </span><span class="cm">/* static predict taken */</span>
<span class="w">  </span><span class="n">BPredNotTaken</span><span class="p">,</span><span class="w">        </span><span class="cm">/* static predict not taken */</span>
<span class="w">  </span><span class="n">BPred_NUM</span>
</code></pre></div></td></tr></table></div>

<p>其中最后一项<code>BPred_NUM</code>只是取巧利用c语言中enum的性质得到predictor种类数目罢了（在c中enum的成员是可以被转化为int类型的，这在强调type safe的c++眼中当然很邪恶，为此c++还有enum class来杜绝这种事），<code>BPredTaken</code>和<code>BPredNotTaken</code>都属于static prediction，
除此之外的前面三个属于dynamic prediction。</p>
<h3 id="static-branch-prediction">static branch prediction</h3>
<p>static branch prediction无疑是最naive的direction predictor，不考虑程序runtime执行的动态信息，只根据当前看到的branch指令来做预测。
SimpleScalar采用了其中最简单的两种策略：</p>
<ul>
<li>
<p>always taken：总是预测branch不会跳转。</p>
</li>
<li>
<p>always not taken：总是预测branch会跳转。</p>
</li>
</ul>
<p>当然这二者预测的准确率就纯靠人品了。
还有稍微高级点的static branch predictor：</p>
<ul>
<li>根据branch target和当前branch指令的pc之间的offset来决定。
如果target在branch指令之前则预测跳转，
如果target在branch指令之后则预测不跳转（backward taken, forward not taken）。
这样的策略是基于程序中常常出现的loop结构，在loop中branch的target通常是backward的。
例如以下这段C代码</li>
</ul>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">100</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">...</span>
<span class="p">}</span>
</code></pre></div></td></tr></table></div>

<p>被翻译成类似下面的汇编代码：</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span>
<span class="normal">4</span>
<span class="normal">5</span></pre></div></td><td class="code"><div><pre><span></span><code>    addi r1, r0, 0
    addi r2, r0, 100
Lable_loop: ...
    addi r1, r1, 1
    bne r1, r2, Lable_loop
</code></pre></div></td></tr></table></div>

<p>如果采用backward taken，则这个loop跑一遍只有最后一次是预测错误，前面九十九次都对了，这就提高了loop结构branch的预测准确率。</p>
<ul>
<li>根据compiler的提示。一般是通过状态寄存器（status register，例如x86体系架构的FLAGS寄存器）来标记branch direction的结果。
（这种策略是把control dependency转化为data dependency。）</li>
</ul>
<h3 id="dynamic-branch-prediction">dynamic branch prediction</h3>
<h4 id="counter-predictor">counter predictor</h4>
<!--
最简单的dynamic branch predictor是counter-based predictor。
这种predictor的想法很简单，只要维护有关branch指令跳转与不跳转的历史，下次再遇到同一条指令时就可以根据该历史来做预测了。
-->
<p>这种predictor的原始想法其实很简单，只要维护有关branch指令跳转与不跳转的历史，下次再遇到同一条指令时就可以根据该历史来做预测了。</p>
<p>一般用来存放跳转历史的数据结构是hash table，
hash table的index是以branch指令的PC（Program Counter）的hash值，
那么hash table的entry应该存什么呢？
最简单的想法就是保存该branch指令上一次是taken还是not taken的信息，显然这样的entry只需一个bit就够了。
当下次再遇到这条branch指令时，我们预测跳转的行为跟其历史是一致的。
我们可以认为hash table存放了供预测用的pattern，所以习惯上也把这张表称为PHT（Pattern History Table）。</p>
<p>还是以类似前面那段for循环的代码为例子，为了便于解释我把循环次数减少到5：</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">...</span>
<span class="p">}</span>
</code></pre></div></td></tr></table></div>

<p>可以被翻译成如下汇编代码：</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span>
<span class="normal">4</span>
<span class="normal">5</span></pre></div></td><td class="code"><div><pre><span></span><code>    addi r1, r0, 0
    addi r2, r0, 5
Lable_loop: ...
    addi r1, r1, 1
    bne r1, r2, Lable_loop
</code></pre></div></td></tr></table></div>

<p>假设branch的跳转历史初始为Not Taken，则跑一遍上述for循环遇到bne指令的情况如下表：</p>
<table border="1" table-layout:fixed>
    <tr>
        <td> r1的值 </td>
        <td> 1 </td>
        <td> 2 </td>
        <td> 3 </td>
        <td> 4 </td>
        <td> 5 </td>
    </tr>
    <tr>
        <td> branch历史 </td>
        <td> Not Taken </td>
        <td> Taken </td>
        <td> Taken </td>
        <td> Taken </td>
        <td> Taken </td>
    </tr>
    <tr>
        <td> 预测 </td>
        <td> Not Taken </td>
        <td> Taken </td>
        <td> Taken </td>
        <td> Taken </td>
        <td> Taken </td>
    </tr>
    <tr>
        <td> 实际情况 </td>
        <td> Taken </td>
        <td> Taken </td>
        <td> Taken </td>
        <td> Taken </td>
        <td> Not Taken </td>
    </tr>
    <tr>
        <td> 正确性 </td>
        <td> 错误 </td>
        <td> 正确 </td>
        <td> 正确 </td>
        <td> 正确 </td>
        <td> 错误 </td>
    </tr>
</table>
<p>于是跑完这个loop一遍的正确率为60%。</p>
<p>这个保存branch上一次是taken还是not taken的entry经常由一个1-bit saturating counter来实现，
这里的saturating是说当counter达到上限（对于1-bit的counter来说是1）时就不再递增，达到下限（对于1-bit的counter来说是0）时就不再递减。
（这也是为什么这种策略被称为counter-based，后面可以看到这也是一种可被拓展的做法。）
对于这种counter-based的实现方法来说，我们要解决的最关键问题是： </p>
<ul>
<li>
<p>如何根据实际的跳转来更新counter？</p>
</li>
<li>
<p>如何根据counter来预测下一次跳转？</p>
</li>
</ul>
<p>假设我们的1-bit saturating counter为1时代表taken，为0时代表not taken，则我们可以这样回答上面两个问题：</p>
<ul>
<li>
<p>counter每遇到实际是taken的情况就做递增，反之则做递减。</p>
</li>
<li>
<p>如果counter的值为1，则预测下次是taken，否则，预测下次是not taken。</p>
</li>
</ul>
<p>不难看出，这样的1-bit saturating counter忠实地模拟了我们之前所用的”branch历史“的行为。
整个方法的原理图如下图所示：</p>
<p><img alt="image" src="/images/branch-predictor/bimodal.png"></p>
<p>另外，当我们审视1-bit saturating counter的update logic，我们会发现counter的更新值（新的状态）取决于counter的旧值（旧的状态）和当前branch实际的跳转情况（输入），这是一个finite-state Moore machine：</p>
<p><img alt="image" src="/images/branch-predictor/FSM-LT.png"></p>
<p>接下来让我们来看看1-bit saturating counter会有什么问题。
假设我们之前例子中的循环体会被执行不止一次——这也是很常见的情况，例如在嵌套循环（nested loop）当中：</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span>
<span class="normal">4</span>
<span class="normal">5</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="p">...</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div></td></tr></table></div>

<p>可以被翻译成如下汇编代码：</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span></pre></div></td><td class="code"><div><pre><span></span><code>    addi r3, r0, 0
    addi r4, r0, 2
Outer_loop: 
        addi r1, r0, 0
        addi r2, r0, 5
    Inner_loop: ...
        addi r1, r1, 1
        bne r1, r2, Inner_loop
    addi r3, r3, 1
    bne r3, r4, Outer_loop
</code></pre></div></td></tr></table></div>

<p>假设<code>bne r1, r2, Inner_loop</code>这条指令的跳转历史初始为Not Taken，同样跑一遍上述for循环遇到<code>bne r1, r2, Inner_loop</code>指令的情况如下表：</p>
<table border="1" table-layout:fixed>
    <tr>
        <td> r1的值 </td>
        <td> 1 </td>
        <td> 2 </td>
        <td> 3 </td>
        <td> 4 </td>
        <td> 5 </td>
        <td> 1 </td>
        <td> 2 </td>
        <td> 3 </td>
        <td> 4 </td>
        <td> 5 </td>
    </tr>
    <tr>
        <td> counter </td>
        <td> 0 </td>
        <td> 1 </td>
        <td> 1 </td>
        <td> 1 </td>
        <td> 1 </td>
        <td> 0 </td>
        <td> 1 </td>
        <td> 1 </td>
        <td> 1 </td>
        <td> 1 </td>
    </tr>
    <tr>
        <td> 预测 </td>
        <td> Not Taken </td>
        <td> Taken </td>
        <td> Taken </td>
        <td> Taken </td>
        <td> Taken </td>
        <td> Not Taken </td>
        <td> Taken </td>
        <td> Taken </td>
        <td> Taken </td>
        <td> Taken </td>
    </tr>
    <tr>
        <td> 实际情况 </td>
        <td> Taken </td>
        <td> Taken </td>
        <td> Taken </td>
        <td> Taken </td>
        <td> Not Taken </td>
        <td> Taken </td>
        <td> Taken </td>
        <td> Taken </td>
        <td> Taken </td>
        <td> Not Taken </td>
    </tr>
    <tr>
        <td> 正确性 </td>
        <td> 错误 </td>
        <td> 正确 </td>
        <td> 正确 </td>
        <td> 正确 </td>
        <td> 错误 </td>
        <td> 错误 </td>
        <td> 正确 </td>
        <td> 正确 </td>
        <td> 正确 </td>
        <td> 错误 </td>
    </tr>
</table>

<p>通过分析它的行为我们可以发现，由于该counter只根据上一次跳转的行为来做预测，所以在最后跳出循环后，我们的counter立即记下是not taken，这样在下次进入该循环体后我们就只能预测not taken，而一般第一次执行循环体都应该是taken，故而我们的predictor在这种naive的情况下还是mispredict了，那么该如何解决这个问题呢？
解决方案就是在预测时不止看一次历史跳转，而是综合多次历史记录。换言之，让我们的PHT entry不那么敏感（sensitive）。
最简单的一种拓展方式就是每个entry增加一个bit，成为一个2-bit saturating counter。
同样，我们不能避开那两个问题，以下是一种解答：</p>
<ul>
<li>
<p>counter每遇到实际是taken的情况就做递增，反之则做递减。</p>
</li>
<li>
<p>如果counter最高位（MSB）的值为1，则预测下次是taken，否则，预测下次是not taken。
我们可以相应地把2-bit saturating counter的值解释为：</p>
</li>
</ul>
<table>
    <header>
        <tr>
            <th>counter值</th>
            <th>含义</th>
        </tr>
    </header>
    <body>
        <tr>
            <td>00</td>
            <td>Strongly Not Taken</td>
        </tr>
        <tr>
            <td>01</td>
            <td>Weakly Not Taken</td>
        </tr>
        <tr>
            <td>10</td>
            <td>Weakly Taken</td>
        </tr>
        <tr>
            <td>11</td>
            <td>Strongly Taken</td>
        </tr>
    </body>
</table>

<p>这时我们的finite state machine就如下图：</p>
<p><img alt="image" src="/images/branch-predictor/FSM-2bit-0.png"></p>
<p>再跑一遍之前的例子。
假设<code>bne r1, r2, Inner_loop</code>这条指令的跳转历史初始为Weakly Not Taken，同样跑一遍上述for循环遇到<code>bne r1, r2, Inner_loop</code>指令的情况如下表：</p>
<table border="1" table-layout:fixed>
    <tr>
        <td> r1的值 </td>
        <td> 1 </td>
        <td> 2 </td>
        <td> 3 </td>
        <td> 4 </td>
        <td> 5 </td>
        <td> 1 </td>
        <td> 2 </td>
        <td> 3 </td>
        <td> 4 </td>
        <td> 5 </td>
    </tr>
    <tr>
        <td> counter </td>
        <td> 01 </td>
        <td> 10 </td>
        <td> 11 </td>
        <td> 11 </td>
        <td> 11 </td>
        <td> 10 </td>
        <td> 11 </td>
        <td> 11 </td>
        <td> 11 </td>
        <td> 10 </td>
    </tr>
    <tr>
        <td> 预测 </td>
        <td> Not Taken </td>
        <td> Taken </td>
        <td> Taken </td>
        <td> Taken </td>
        <td> Taken </td>
        <td> Not Taken </td>
        <td> Taken </td>
        <td> Taken </td>
        <td> Taken </td>
        <td> Taken </td>
    </tr>
    <tr>
        <td> 实际情况 </td>
        <td> Taken </td>
        <td> Taken </td>
        <td> Taken </td>
        <td> Taken </td>
        <td> Not Taken </td>
        <td> Taken </td>
        <td> Taken </td>
        <td> Taken </td>
        <td> Taken </td>
        <td> Not Taken </td>
    </tr>
    <tr>
        <td> 正确性 </td>
        <td> 错误 </td>
        <td> 正确 </td>
        <td> 正确 </td>
        <td> 正确 </td>
        <td> 错误 </td>
        <td> 正确 </td>
        <td> 正确 </td>
        <td> 正确 </td>
        <td> 正确 </td>
        <td> 错误 </td>
    </tr>
</table>

<p>不难看出，由于2-bit saturating counter正确地处理了1-bit saturating counter在再次进入循环体的预测错误，使得正确率从60%提升到了70%。</p>
<p>值得一提的是，用2-bit counter来实现并非只有上述方法。以下这几种FSM同样可以，例如采用第一个FSM的话，则连续发生两次Not Taken时就设为Strongly Not Taken。</p>
<p><img alt="image" src="/images/branch-predictor/FSM-2bit-1.png">
<img alt="image" src="/images/branch-predictor/FSM-2bit-2.png">
<img alt="image" src="/images/branch-predictor/FSM-2bit-3.png"></p>
<p>再拓展开去，PHT的entry可以是任意位（bit）的saturating counter，counter的位数（width）越多，predictor的更新就越不敏感。
不过实际上不会用到太多bit，2 bit和3 bit是最常见的（例如Alpha 21264就用的是3-bit saturating counter）。
不过，也许你已经发现了，我们的saturating counter的初始值是有讲究的。上例用的是Weakly Not Taken，其实Weakly Taken也可以，但是如果初始值设为Strongly (Not) Taken，效果就不如人意了。这是因为一开始我们的predictor没有任何历史的信息，让saturating counter变得敏感一些有助于记住正确的pattern。saturating counter的位数越多，设为敏感值的优势越多。</p>
<p>回到SimpleScalar的source code，SimpleScalar所实现的正是上文所讲的2-bit saturating counter（即source code中的<code>BPred2bit</code>）。</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="cm">/* create a branch predictor */</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">bpred_t</span><span class="w"> </span><span class="o">*</span><span class="w">            </span><span class="cm">/* branch predictory instance */</span>
<span class="n">bpred_create</span><span class="p">(</span><span class="k">enum</span><span class="w"> </span><span class="n">bpred_class</span><span class="w"> </span><span class="n">class</span><span class="p">,</span><span class="w">    </span><span class="cm">/* type of predictor to create */</span>
<span class="w">         </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">bimod_size</span><span class="p">,</span><span class="w">   </span><span class="cm">/* bimod table size */</span>
<span class="w">         </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">l1size</span><span class="p">,</span><span class="w">   </span><span class="cm">/* 2lev l1 table size */</span>
<span class="w">         </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">l2size</span><span class="p">,</span><span class="w">   </span><span class="cm">/* 2lev l2 table size */</span>
<span class="w">         </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">meta_size</span><span class="p">,</span><span class="w">    </span><span class="cm">/* meta table size */</span>
<span class="w">         </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">shift_width</span><span class="p">,</span><span class="w">  </span><span class="cm">/* history register width */</span>
<span class="w">         </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">xor</span><span class="p">,</span><span class="w">      </span><span class="cm">/* history xor address flag */</span>
<span class="w">         </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">btb_sets</span><span class="p">,</span><span class="w"> </span><span class="cm">/* number of sets in BTB */</span><span class="w"> </span>
<span class="w">         </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">btb_assoc</span><span class="p">,</span><span class="w">    </span><span class="cm">/* BTB associativity */</span>
<span class="w">         </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">retstack_size</span><span class="p">)</span><span class="w"> </span><span class="cm">/* num entries in ret-addr stack */</span>
</code></pre></div></td></tr></table></div>

<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span>
<span class="normal">4</span>
<span class="normal">5</span>
<span class="normal">6</span>
<span class="normal">7</span>
<span class="normal">8</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="cm">/* create a branch direction predictor */</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">bpred_dir_t</span><span class="w"> </span><span class="o">*</span><span class="w">        </span><span class="cm">/* branch direction predictor instance */</span>
<span class="n">bpred_dir_create</span><span class="w"> </span><span class="p">(</span>
<span class="w">  </span><span class="k">enum</span><span class="w"> </span><span class="n">bpred_class</span><span class="w"> </span><span class="n">class</span><span class="p">,</span><span class="w">   </span><span class="cm">/* type of predictor to create */</span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">l1size</span><span class="p">,</span><span class="w">      </span><span class="cm">/* level-1 table size */</span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">l2size</span><span class="p">,</span><span class="w">      </span><span class="cm">/* level-2 table size (if relevant) */</span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">shift_width</span><span class="p">,</span><span class="w"> </span><span class="cm">/* history register width */</span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">xor</span><span class="p">)</span><span class="w">         </span><span class="cm">/* history xor address flag */</span>
</code></pre></div></td></tr></table></div>

<p>如前所述，SimpleScalar的branch direction predictor是一个<code>struct bpred_dir_t</code>，<code>BPred2bit</code>的结构定义就在<code>struct bpred_dir_t</code>中：</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span>
<span class="normal">4</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">size</span><span class="p">;</span><span class="w">    </span><span class="cm">/* number of entries in direct-mapped table */</span>
<span class="w">      </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">table</span><span class="p">;</span><span class="w"> </span><span class="cm">/* prediction state table */</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="n">bimod</span><span class="p">;</span>
</code></pre></div></td></tr></table></div>

<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="cm">/* direction predictor def */</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">bpred_dir_t</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">enum</span><span class="w"> </span><span class="n">bpred_class</span><span class="w"> </span><span class="n">class</span><span class="p">;</span><span class="w">   </span><span class="cm">/* type of predictor */</span>
<span class="w">  </span><span class="k">union</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">size</span><span class="p">;</span><span class="w">    </span><span class="cm">/* number of entries in direct-mapped table */</span>
<span class="w">      </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">table</span><span class="p">;</span><span class="w"> </span><span class="cm">/* prediction state table */</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="n">bimod</span><span class="p">;</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="kt">int</span><span class="w"> </span><span class="n">l1size</span><span class="p">;</span><span class="w">       </span><span class="cm">/* level-1 size, number of history regs */</span>
<span class="w">      </span><span class="kt">int</span><span class="w"> </span><span class="n">l2size</span><span class="p">;</span><span class="w">       </span><span class="cm">/* level-2 size, number of pred states */</span>
<span class="w">      </span><span class="kt">int</span><span class="w"> </span><span class="n">shift_width</span><span class="p">;</span><span class="w">      </span><span class="cm">/* amount of history in level-1 shift regs */</span>
<span class="w">      </span><span class="kt">int</span><span class="w"> </span><span class="n">xor</span><span class="p">;</span><span class="w">          </span><span class="cm">/* history xor address flag */</span>
<span class="w">      </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">shiftregs</span><span class="p">;</span><span class="w">       </span><span class="cm">/* level-1 history table */</span>
<span class="w">      </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">l2table</span><span class="p">;</span><span class="w">   </span><span class="cm">/* level-2 prediction state table */</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="n">two</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="n">config</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></td></tr></table></div>

<p>其中代码注释中的prediction state table就是我们所说的PHT，size表示PHT的entries数目。</p>
<p>让我们先来看看<code>BPred2bit</code> predictor的初始化。首先<code>bpred_create</code>函数被调用来创建branch predictor（即<code>bpred_t</code>结构），在该函数中<code>bpred_dir_create</code>函数被调用来创建direction branch predictor部分（即<code>bpred_dir_t</code>结构），<code>BPred2bit</code>的初始化就在函数<code>bpred_dir_create</code>的以下几行代码中：</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">bpred_dir_t</span><span class="w"> </span><span class="o">*</span><span class="n">pred_dir</span><span class="p">;</span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">cnt</span><span class="p">;</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">flipflop</span><span class="p">;</span>
<span class="w">  </span><span class="c1">// omit some code here...</span>
<span class="w">  </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">class</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="no">BPred2bit</span><span class="p">:</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">l1size</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="p">(</span><span class="n">l1size</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="p">(</span><span class="n">l1size</span><span class="mi">-1</span><span class="p">))</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">      </span><span class="n">fatal</span><span class="p">(</span><span class="s">&quot;2bit table size, `%d&#39;, must be non-zero and a power of two&quot;</span><span class="p">,</span><span class="w"> </span>
<span class="w">        </span><span class="n">l1size</span><span class="p">);</span>
<span class="w">    </span><span class="n">pred_dir</span><span class="o">-&gt;</span><span class="n">config</span><span class="p">.</span><span class="n">bimod</span><span class="p">.</span><span class="n">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">l1size</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">pred_dir</span><span class="o">-&gt;</span><span class="n">config</span><span class="p">.</span><span class="n">bimod</span><span class="p">.</span><span class="n">table</span><span class="w"> </span><span class="o">=</span>
<span class="w">      </span><span class="n">calloc</span><span class="p">(</span><span class="n">l1size</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="p">))))</span>
<span class="w">      </span><span class="n">fatal</span><span class="p">(</span><span class="s">&quot;cannot allocate 2bit storage&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="cm">/* initialize counters to weakly this-or-that */</span>
<span class="w">    </span><span class="n">flipflop</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">cnt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">cnt</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">l1size</span><span class="p">;</span><span class="w"> </span><span class="n">cnt</span><span class="o">++</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">      </span><span class="n">pred_dir</span><span class="o">-&gt;</span><span class="n">config</span><span class="p">.</span><span class="n">bimod</span><span class="p">.</span><span class="n">table</span><span class="p">[</span><span class="n">cnt</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">flipflop</span><span class="p">;</span>
<span class="w">      </span><span class="n">flipflop</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">flipflop</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">break</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
</code></pre></div></td></tr></table></div>

<p>这段代码先检查PHT的entries数目（即代码中的<code>l1size</code>）是否合法——这个数目取决于用来做index的寄存器的位数（width），如果我们取PC的某$M$位作为index，则entries数目只能是$2^M$。
如果<code>l1size</code>合法，则为PHT分配空间。
接下来把PHT的每个entry都初始化为Weakly Not Taken（对于2-bit saturating counter来说就是1）。</p>
<!-- 
也就是branch应当为not taken时，我们的predictor仍然会预测 
-->

<p>(待续)</p>
<h4 id="correlated-branch-predictor">correlated branch predictor</h4>
<h4 id="2-level-branch-predictor">2-level branch predictor</h4>
<h4 id="gshare-branch-predictor">gshare branch predictor</h4>
<h4 id="hybrid-branch-predictor">hybrid branch predictor</h4>
<h2 id="_1">参考资料</h2>
<p>[1]<a href="http://www.hpl.hp.com/techreports/Compaq-DEC/WRL-TN-36.pdf">McFarling S. Combining branch predictors[R]. Technical Report TN-36, Digital Western Research Laboratory, 1993.</a></p>


             
 
            
            
            







            <hr/>
        </div>
        <section id="article-sidebar" class="span2">
            <h4>Published</h4>
            <time itemprop="dateCreated" datetime="2013-07-22T17:10:00+08:00">Mon 22 July 2013</time>
            <h4>Category</h4>
            <a class="category-link" href="http://yszheda.github.io/blog/categories.html#tech-ref">tech</a>
            <h4>Tags</h4>
            <ul class="list-of-tags tags-in-article">
                <li><a href="http://yszheda.github.io/blog/tags.html#branch-prediction-ref">Branch Prediction
                    <span class="superscript">2</span>
</a></li>
                <li><a href="http://yszheda.github.io/blog/tags.html#computer-architecture-ref">Computer Architecture
                    <span class="superscript">2</span>
</a></li>
                <li><a href="http://yszheda.github.io/blog/tags.html#cs-ref">CS
                    <span class="superscript">48</span>
</a></li>
                <li><a href="http://yszheda.github.io/blog/tags.html#fen-zhi-yu-ce-ref">分支预测
                    <span class="superscript">2</span>
</a></li>
                <li><a href="http://yszheda.github.io/blog/tags.html#ji-suan-ji-ti-xi-ref">计算机体系
                    <span class="superscript">2</span>
</a></li>
                <li><a href="http://yszheda.github.io/blog/tags.html#simplescalar-ref">SimpleScalar
                    <span class="superscript">2</span>
</a></li>
                <li><a href="http://yszheda.github.io/blog/tags.html#tech-ref">tech
                    <span class="superscript">48</span>
</a></li>
                <li><a href="http://yszheda.github.io/blog/tags.html#ti-xi-jie-gou-ref">体系结构
                    <span class="superscript">2</span>
</a></li>
            </ul>
<h4>Contact</h4>
<div id="sidebar-social-link">
    <a href="https://github.com/yszheda" title="" target="_blank" rel="nofollow noopener noreferrer">
        <svg xmlns="http://www.w3.org/2000/svg" aria-label="GitHub" role="img" viewBox="0 0 512 512"><rect width="512" height="512" rx="15%" fill="#1B1817"/><path fill="#fff" d="M335 499c14 0 12 17 12 17H165s-2-17 12-17c13 0 16-6 16-12l-1-50c-71 16-86-28-86-28-12-30-28-37-28-37-24-16 1-16 1-16 26 2 40 26 40 26 22 39 59 28 74 22 2-17 9-28 16-35-57-6-116-28-116-126 0-28 10-51 26-69-3-6-11-32 3-67 0 0 21-7 70 26 42-12 86-12 128 0 49-33 70-26 70-26 14 35 6 61 3 67 16 18 26 41 26 69 0 98-60 120-117 126 10 8 18 24 18 48l-1 70c0 6 3 12 16 12z"/></svg>
    </a>
    <a href="https://twitter.com/yszheda" title="" target="_blank" rel="nofollow noopener noreferrer">
        <svg xmlns="http://www.w3.org/2000/svg" aria-label="Twitter" role="img" viewBox="0 0 512 512"><rect width="512" height="512" rx="15%" fill="#1da1f3"/><path fill="#fff" d="M437 152a72 72 0 0 1-40 12 72 72 0 0 0 32-40 72 72 0 0 1-45 17 72 72 0 0 0-122 65 200 200 0 0 1-145-74 72 72 0 0 0 22 94 72 72 0 0 1-32-7 72 72 0 0 0 56 69 72 72 0 0 1-32 1 72 72 0 0 0 67 50 200 200 0 0 1-105 29 200 200 0 0 0 309-179 200 200 0 0 0 35-37"/></svg>
    </a>
</div>
            





            





        </section>
</div>
</article>
<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe.
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides.
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo https://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>                    </div>
                    <div class="span1"></div>
                </div>
            </div>
        </div>
<footer>




    <div id="fpowered">
        Powered by: <a href="http://getpelican.com/" title="Pelican Home Page" target="_blank" rel="nofollow noopener noreferrer">Pelican</a>
        Theme: <a href="https://elegant.oncrashreboot.com/" title="Theme Elegant Home Page" target="_blank" rel="nofollow noopener noreferrer">Elegant</a>
    </div>
</footer>            <script src="//code.jquery.com/jquery.min.js"></script>
        <script src="//netdna.bootstrapcdn.com/twitter-bootstrap/2.3.2/js/bootstrap.min.js"></script>
        <script src="http://yszheda.github.io/blog/theme/js/elegant.prod.9e9d5ce754.js"></script>
        <script>
            function validateForm(query)
            {
                return (query.length > 0);
            }
        </script>

    <script>
    (function () {
        if (window.location.hash.match(/^#comment-\d+$/)) {
            $('#comment_thread').collapse('show');
        }
    })();
    window.onhashchange=function(){
        if (window.location.hash.match(/^#comment-\d+$/))
            window.location.reload(true);
    }
    $('#comment_thread').on('shown', function () {
        var link = document.getElementById('comment-accordion-toggle');
        var old_innerHTML = link.innerHTML;
        $(link).fadeOut(200, function() {
            $(this).text('Click here to hide comments').fadeIn(200);
        });
        $('#comment_thread').on('hidden', function () {
            $(link).fadeOut(200, function() {
                $(this).text(old_innerHTML).fadeIn(200);
            });
        })
    })
</script>

    </body>
    <!-- Theme: Elegant built for Pelican
        License : MIT -->
</html>