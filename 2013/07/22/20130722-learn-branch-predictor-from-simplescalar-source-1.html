<!DOCTYPE html>
<html lang="zh">
        <head>
                        <meta charset="utf-8" />
                        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
                        <meta name="generator" content="Pelican" />
                        <title>Learn branch prediction from SimpleScalar source (1)</title>
                        <link rel="stylesheet" href="../../../theme/css/main.css" />
    <meta name="description" content="作为一名CSer，最好的学习方式之一无疑是tracing code，看源代码—— 不知你此时是否与我一样想起了Linus那句名言「talk is cheap, show me the fucking code!」? 可是对计 …" />
        </head>

        <body id="index" class="home">
                <header id="banner" class="body">
                        <h1><a href="../../../">Galoisplusplus</a></h1>
                        <nav><ul>
                                                <li><a href="../../../category/misc.html">misc</a></li>
                                                <li><a href="../../../category/music.html">music</a></li>
                                                <li><a href="../../../category/reading.html">reading</a></li>
                                                <li class="active"><a href="../../../category/tech.html">tech</a></li>
                        </ul></nav>
                </header><!-- /#banner -->
  <section id="content" class="body">
    <article>
      <header>
        <h1 class="entry-title">
          <a href="../../../2013/07/22/20130722-learn-branch-predictor-from-simplescalar-source-1.html" rel="bookmark"
             title="Permalink to Learn branch prediction from SimpleScalar source (1)">Learn branch prediction from SimpleScalar source (1)</a></h1>
      </header>

      <div class="entry-content">
<footer class="post-info">
        <abbr class="published" title="2013-07-22T17:10:00+08:00">
                Published: 一 22 7月 2013
        </abbr>

                <address class="vcard author">
                        By                                 <a class="url fn" href="../../../author/galoisplusplus.html">Galoisplusplus</a>
                </address>
        <p>In <a href="../../../category/tech.html">tech</a>.</p>
<p>tags: <a href="../../../tag/tech.html">tech</a> <a href="../../../tag/cs.html">CS</a> <a href="../../../tag/branch-prediction.html">Branch Prediction</a> <a href="../../../tag/simplescalar.html">SimpleScalar</a> <a href="../../../tag/computer-architecture.html">Computer Architecture</a> <a href="../../../tag/fen-zhi-yu-ce.html">分支预测</a> <a href="../../../tag/ti-xi-jie-gou.html">体系结构</a> <a href="../../../tag/ji-suan-ji-ti-xi.html">计算机体系</a> </p>        
</footer><!-- /.post-info -->        <p>作为一名CSer，最好的学习方式之一无疑是tracing code，看源代码——
不知你此时是否与我一样想起了Linus那句名言「talk is cheap, show me the <del>fucking</del> code!」?
可是对计算机体系结构来说，很多技术直接是由硬件实现的，因而也被蒙上一层神秘的面纱。
好在还有一些模拟器（simulator）软件，例如SimpleScalar(http://www.simplescalar.com/)就是这样一套模拟处理器性能的工具集。
之前我有幸通过做一些project接触SimpleScalar并读了一些cache技术的源代码。
在此我借SimpleScalar源代码为工具介绍branch prediction技术，
也算是对几个月前折腾时光的一种整理吧~</p>
<p>首先先简单介绍下branch prediction是做神马。
branch是instruction sets里面十分常见的一类指令。
一般可以分为：</p>
<ul>
<li>
<p>conditional branch：只在某条件下才跳转。例如<code>MIPS</code>里的<code>beq</code>/<code>bne</code>等。</p>
</li>
<li>
<p>unconditional branch（或简称jump）: 无条件跳转。例如<code>MIPS</code>里的<code>j</code>/<code>jr</code>等。</p>
</li>
<li>
<p>还有一类特殊的跳转指令，就是function call和return。</p>
</li>
</ul>
<!-- more -->

<p>这类指令在一般程序里的出现频率是很高的，据说平均每4至5条指令就会出现一条branch指令，这也是为什么大多数<code>basic block</code>都很短的原因。
不幸的是，在我们CPU的pipeline中我们常常要在后面的stage才能得到branch的结果。
显然在fetch到branch指令与resolve出结果之间「漫长」的clock cycle中，我们希望能同时处理之后的指令。
那么在resolve之前我们怎么知道branch之后的指令是什么？
这时候我们就需要branch prediction了。</p>
<p>简单地说，branch prediction要预测的主要是两件事：</p>
<ul>
<li>
<p>direction：conditional branch是taken还是not taken？</p>
</li>
<li>
<p>target：branch指令要跳转的目的地是哪里？除了conditional branch，这也包括function pointer和indirect jump，例如<code>MPIS</code>中的<code>jr</code>指令就需要在计算出<code>r31</code>的值后才知道跳转目标。</p>
</li>
</ul>
<p>针对预测direction的有branch direction predictor；
针对预测target的有一般的BTB(Branch Target Buffer)，
还有针对call和return的RAS(Return Address Stack)。
在SimpleScalar中，branch predictor被定义为以下structure：</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="cm">/* branch predictor def */</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">bpred_t</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">enum</span><span class="w"> </span><span class="n">bpred_class</span><span class="w"> </span><span class="n">class</span><span class="p">;</span><span class="w">   </span><span class="cm">/* type of predictor */</span>
<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">bpred_dir_t</span><span class="w"> </span><span class="o">*</span><span class="n">bimod</span><span class="p">;</span><span class="w">    </span><span class="cm">/* first direction predictor */</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">bpred_dir_t</span><span class="w"> </span><span class="o">*</span><span class="n">twolev</span><span class="p">;</span><span class="w">   </span><span class="cm">/* second direction predictor */</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">bpred_dir_t</span><span class="w"> </span><span class="o">*</span><span class="n">meta</span><span class="p">;</span><span class="w">     </span><span class="cm">/* meta predictor */</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="n">dirpred</span><span class="p">;</span>

<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">sets</span><span class="p">;</span><span class="w">           </span><span class="cm">/* num BTB sets */</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">assoc</span><span class="p">;</span><span class="w">          </span><span class="cm">/* BTB associativity */</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">bpred_btb_ent_t</span><span class="w"> </span><span class="o">*</span><span class="n">btb_data</span><span class="p">;</span><span class="w"> </span><span class="cm">/* BTB addr-prediction table */</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="n">btb</span><span class="p">;</span>

<span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">size</span><span class="p">;</span><span class="w">           </span><span class="cm">/* return-address stack size */</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">tos</span><span class="p">;</span><span class="w">            </span><span class="cm">/* top-of-stack */</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">bpred_btb_ent_t</span><span class="w"> </span><span class="o">*</span><span class="n">stack</span><span class="p">;</span><span class="w"> </span><span class="cm">/* return-address stack */</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="n">retstack</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// 以下省略模拟用的状态计数器</span>
<span class="p">}</span>
</code></pre></div></td></tr></table></div>

<p>以下我将针对各部分进行介绍。</p>
<h2 id="branch-direction-predictor">branch direction predictor</h2>
<p>在SimpleScalar中定义了如下的direction predictor类别：</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span>
<span class="normal">4</span>
<span class="normal">5</span>
<span class="normal">6</span>
<span class="normal">7</span>
<span class="normal">8</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="cm">/* branch predictor types */</span>
<span class="k">enum</span><span class="w"> </span><span class="n">bpred_class</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">BPredComb</span><span class="p">,</span><span class="w">            </span><span class="cm">/* combined predictor (McFarling) */</span>
<span class="w">  </span><span class="n">BPred2Level</span><span class="p">,</span><span class="w">          </span><span class="cm">/* 2-level correlating pred w/2-bit counters */</span>
<span class="w">  </span><span class="n">BPred2bit</span><span class="p">,</span><span class="w">            </span><span class="cm">/* 2-bit saturating cntr pred (dir mapped) */</span>
<span class="w">  </span><span class="n">BPredTaken</span><span class="p">,</span><span class="w">           </span><span class="cm">/* static predict taken */</span>
<span class="w">  </span><span class="n">BPredNotTaken</span><span class="p">,</span><span class="w">        </span><span class="cm">/* static predict not taken */</span>
<span class="w">  </span><span class="n">BPred_NUM</span>
</code></pre></div></td></tr></table></div>

<p>其中最后一项<code>BPred_NUM</code>只是取巧利用c语言中enum的性质得到predictor种类数目罢了（在c中enum的成员是可以被转化为int类型的，这在强调type safe的c++眼中当然很邪恶，为此c++还有enum class来杜绝这种事），<code>BPredTaken</code>和<code>BPredNotTaken</code>都属于static prediction，
除此之外的前面三个属于dynamic prediction。</p>
<h3 id="static-branch-prediction">static branch prediction</h3>
<p>static branch prediction无疑是最naive的direction predictor，不考虑程序runtime执行的动态信息，只根据当前看到的branch指令来做预测。
SimpleScalar采用了其中最简单的两种策略：</p>
<ul>
<li>
<p>always taken：总是预测branch不会跳转。</p>
</li>
<li>
<p>always not taken：总是预测branch会跳转。</p>
</li>
</ul>
<p>当然这二者预测的准确率就纯靠人品了。
还有稍微高级点的static branch predictor：</p>
<ul>
<li>根据branch target和当前branch指令的pc之间的offset来决定。
如果target在branch指令之前则预测跳转，
如果target在branch指令之后则预测不跳转（backward taken, forward not taken）。
这样的策略是基于程序中常常出现的loop结构，在loop中branch的target通常是backward的。
例如以下这段C代码</li>
</ul>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">100</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">...</span>
<span class="p">}</span>
</code></pre></div></td></tr></table></div>

<p>被翻译成类似下面的汇编代码：</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span>
<span class="normal">4</span>
<span class="normal">5</span></pre></div></td><td class="code"><div><pre><span></span><code>    addi r1, r0, 0
    addi r2, r0, 100
Lable_loop: ...
    addi r1, r1, 1
    bne r1, r2, Lable_loop
</code></pre></div></td></tr></table></div>

<p>如果采用backward taken，则这个loop跑一遍只有最后一次是预测错误，前面九十九次都对了，这就提高了loop结构branch的预测准确率。</p>
<ul>
<li>根据compiler的提示。一般是通过状态寄存器（status register，例如x86体系架构的FLAGS寄存器）来标记branch direction的结果。
（这种策略是把control dependency转化为data dependency。）</li>
</ul>
<h3 id="dynamic-branch-prediction">dynamic branch prediction</h3>
<h4 id="counter-predictor">counter predictor</h4>
<!--
最简单的dynamic branch predictor是counter-based predictor。
这种predictor的想法很简单，只要维护有关branch指令跳转与不跳转的历史，下次再遇到同一条指令时就可以根据该历史来做预测了。
-->
<p>这种predictor的原始想法其实很简单，只要维护有关branch指令跳转与不跳转的历史，下次再遇到同一条指令时就可以根据该历史来做预测了。</p>
<p>一般用来存放跳转历史的数据结构是hash table，
hash table的index是以branch指令的PC（Program Counter）的hash值，
那么hash table的entry应该存什么呢？
最简单的想法就是保存该branch指令上一次是taken还是not taken的信息，显然这样的entry只需一个bit就够了。
当下次再遇到这条branch指令时，我们预测跳转的行为跟其历史是一致的。
我们可以认为hash table存放了供预测用的pattern，所以习惯上也把这张表称为PHT（Pattern History Table）。</p>
<p>还是以类似前面那段for循环的代码为例子，为了便于解释我把循环次数减少到5：</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="p">...</span>
<span class="p">}</span>
</code></pre></div></td></tr></table></div>

<p>可以被翻译成如下汇编代码：</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span>
<span class="normal">4</span>
<span class="normal">5</span></pre></div></td><td class="code"><div><pre><span></span><code>    addi r1, r0, 0
    addi r2, r0, 5
Lable_loop: ...
    addi r1, r1, 1
    bne r1, r2, Lable_loop
</code></pre></div></td></tr></table></div>

<p>假设branch的跳转历史初始为Not Taken，则跑一遍上述for循环遇到bne指令的情况如下表：</p>
<table border="1" table-layout:fixed>
    <tr>
        <td> r1的值 </td>
        <td> 1 </td>
        <td> 2 </td>
        <td> 3 </td>
        <td> 4 </td>
        <td> 5 </td>
    </tr>
    <tr>
        <td> branch历史 </td>
        <td> Not Taken </td>
        <td> Taken </td>
        <td> Taken </td>
        <td> Taken </td>
        <td> Taken </td>
    </tr>
    <tr>
        <td> 预测 </td>
        <td> Not Taken </td>
        <td> Taken </td>
        <td> Taken </td>
        <td> Taken </td>
        <td> Taken </td>
    </tr>
    <tr>
        <td> 实际情况 </td>
        <td> Taken </td>
        <td> Taken </td>
        <td> Taken </td>
        <td> Taken </td>
        <td> Not Taken </td>
    </tr>
    <tr>
        <td> 正确性 </td>
        <td> 错误 </td>
        <td> 正确 </td>
        <td> 正确 </td>
        <td> 正确 </td>
        <td> 错误 </td>
    </tr>
</table>
<p>于是跑完这个loop一遍的正确率为60%。</p>
<p>这个保存branch上一次是taken还是not taken的entry经常由一个1-bit saturating counter来实现，
这里的saturating是说当counter达到上限（对于1-bit的counter来说是1）时就不再递增，达到下限（对于1-bit的counter来说是0）时就不再递减。
（这也是为什么这种策略被称为counter-based，后面可以看到这也是一种可被拓展的做法。）
对于这种counter-based的实现方法来说，我们要解决的最关键问题是： </p>
<ul>
<li>
<p>如何根据实际的跳转来更新counter？</p>
</li>
<li>
<p>如何根据counter来预测下一次跳转？</p>
</li>
</ul>
<p>假设我们的1-bit saturating counter为1时代表taken，为0时代表not taken，则我们可以这样回答上面两个问题：</p>
<ul>
<li>
<p>counter每遇到实际是taken的情况就做递增，反之则做递减。</p>
</li>
<li>
<p>如果counter的值为1，则预测下次是taken，否则，预测下次是not taken。</p>
</li>
</ul>
<p>不难看出，这样的1-bit saturating counter忠实地模拟了我们之前所用的”branch历史“的行为。
整个方法的原理图如下图所示：</p>
<p><img alt="image" src="/images/branch-predictor/bimodal.png"></p>
<p>另外，当我们审视1-bit saturating counter的update logic，我们会发现counter的更新值（新的状态）取决于counter的旧值（旧的状态）和当前branch实际的跳转情况（输入），这是一个finite-state Moore machine：</p>
<p><img alt="image" src="/images/branch-predictor/FSM-LT.png"></p>
<p>接下来让我们来看看1-bit saturating counter会有什么问题。
假设我们之前例子中的循环体会被执行不止一次——这也是很常见的情况，例如在嵌套循环（nested loop）当中：</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span>
<span class="normal">4</span>
<span class="normal">5</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="n">j</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="p">...</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div></td></tr></table></div>

<p>可以被翻译成如下汇编代码：</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span></pre></div></td><td class="code"><div><pre><span></span><code>    addi r3, r0, 0
    addi r4, r0, 2
Outer_loop: 
        addi r1, r0, 0
        addi r2, r0, 5
    Inner_loop: ...
        addi r1, r1, 1
        bne r1, r2, Inner_loop
    addi r3, r3, 1
    bne r3, r4, Outer_loop
</code></pre></div></td></tr></table></div>

<p>假设<code>bne r1, r2, Inner_loop</code>这条指令的跳转历史初始为Not Taken，同样跑一遍上述for循环遇到<code>bne r1, r2, Inner_loop</code>指令的情况如下表：</p>
<table border="1" table-layout:fixed>
    <tr>
        <td> r1的值 </td>
        <td> 1 </td>
        <td> 2 </td>
        <td> 3 </td>
        <td> 4 </td>
        <td> 5 </td>
        <td> 1 </td>
        <td> 2 </td>
        <td> 3 </td>
        <td> 4 </td>
        <td> 5 </td>
    </tr>
    <tr>
        <td> counter </td>
        <td> 0 </td>
        <td> 1 </td>
        <td> 1 </td>
        <td> 1 </td>
        <td> 1 </td>
        <td> 0 </td>
        <td> 1 </td>
        <td> 1 </td>
        <td> 1 </td>
        <td> 1 </td>
    </tr>
    <tr>
        <td> 预测 </td>
        <td> Not Taken </td>
        <td> Taken </td>
        <td> Taken </td>
        <td> Taken </td>
        <td> Taken </td>
        <td> Not Taken </td>
        <td> Taken </td>
        <td> Taken </td>
        <td> Taken </td>
        <td> Taken </td>
    </tr>
    <tr>
        <td> 实际情况 </td>
        <td> Taken </td>
        <td> Taken </td>
        <td> Taken </td>
        <td> Taken </td>
        <td> Not Taken </td>
        <td> Taken </td>
        <td> Taken </td>
        <td> Taken </td>
        <td> Taken </td>
        <td> Not Taken </td>
    </tr>
    <tr>
        <td> 正确性 </td>
        <td> 错误 </td>
        <td> 正确 </td>
        <td> 正确 </td>
        <td> 正确 </td>
        <td> 错误 </td>
        <td> 错误 </td>
        <td> 正确 </td>
        <td> 正确 </td>
        <td> 正确 </td>
        <td> 错误 </td>
    </tr>
</table>

<p>通过分析它的行为我们可以发现，由于该counter只根据上一次跳转的行为来做预测，所以在最后跳出循环后，我们的counter立即记下是not taken，这样在下次进入该循环体后我们就只能预测not taken，而一般第一次执行循环体都应该是taken，故而我们的predictor在这种naive的情况下还是mispredict了，那么该如何解决这个问题呢？
解决方案就是在预测时不止看一次历史跳转，而是综合多次历史记录。换言之，让我们的PHT entry不那么敏感（sensitive）。
最简单的一种拓展方式就是每个entry增加一个bit，成为一个2-bit saturating counter。
同样，我们不能避开那两个问题，以下是一种解答：</p>
<ul>
<li>
<p>counter每遇到实际是taken的情况就做递增，反之则做递减。</p>
</li>
<li>
<p>如果counter最高位（MSB）的值为1，则预测下次是taken，否则，预测下次是not taken。
我们可以相应地把2-bit saturating counter的值解释为：</p>
</li>
</ul>
<table>
    <header>
        <tr>
            <th>counter值</th>
            <th>含义</th>
        </tr>
    </header>
    <body>
        <tr>
            <td>00</td>
            <td>Strongly Not Taken</td>
        </tr>
        <tr>
            <td>01</td>
            <td>Weakly Not Taken</td>
        </tr>
        <tr>
            <td>10</td>
            <td>Weakly Taken</td>
        </tr>
        <tr>
            <td>11</td>
            <td>Strongly Taken</td>
        </tr>
    </body>
</table>

<p>这时我们的finite state machine就如下图：</p>
<p><img alt="image" src="/images/branch-predictor/FSM-2bit-0.png"></p>
<p>再跑一遍之前的例子。
假设<code>bne r1, r2, Inner_loop</code>这条指令的跳转历史初始为Weakly Not Taken，同样跑一遍上述for循环遇到<code>bne r1, r2, Inner_loop</code>指令的情况如下表：</p>
<table border="1" table-layout:fixed>
    <tr>
        <td> r1的值 </td>
        <td> 1 </td>
        <td> 2 </td>
        <td> 3 </td>
        <td> 4 </td>
        <td> 5 </td>
        <td> 1 </td>
        <td> 2 </td>
        <td> 3 </td>
        <td> 4 </td>
        <td> 5 </td>
    </tr>
    <tr>
        <td> counter </td>
        <td> 01 </td>
        <td> 10 </td>
        <td> 11 </td>
        <td> 11 </td>
        <td> 11 </td>
        <td> 10 </td>
        <td> 11 </td>
        <td> 11 </td>
        <td> 11 </td>
        <td> 10 </td>
    </tr>
    <tr>
        <td> 预测 </td>
        <td> Not Taken </td>
        <td> Taken </td>
        <td> Taken </td>
        <td> Taken </td>
        <td> Taken </td>
        <td> Not Taken </td>
        <td> Taken </td>
        <td> Taken </td>
        <td> Taken </td>
        <td> Taken </td>
    </tr>
    <tr>
        <td> 实际情况 </td>
        <td> Taken </td>
        <td> Taken </td>
        <td> Taken </td>
        <td> Taken </td>
        <td> Not Taken </td>
        <td> Taken </td>
        <td> Taken </td>
        <td> Taken </td>
        <td> Taken </td>
        <td> Not Taken </td>
    </tr>
    <tr>
        <td> 正确性 </td>
        <td> 错误 </td>
        <td> 正确 </td>
        <td> 正确 </td>
        <td> 正确 </td>
        <td> 错误 </td>
        <td> 正确 </td>
        <td> 正确 </td>
        <td> 正确 </td>
        <td> 正确 </td>
        <td> 错误 </td>
    </tr>
</table>

<p>不难看出，由于2-bit saturating counter正确地处理了1-bit saturating counter在再次进入循环体的预测错误，使得正确率从60%提升到了70%。</p>
<p>值得一提的是，用2-bit counter来实现并非只有上述方法。以下这几种FSM同样可以，例如采用第一个FSM的话，则连续发生两次Not Taken时就设为Strongly Not Taken。</p>
<p><img alt="image" src="/images/branch-predictor/FSM-2bit-1.png">
<img alt="image" src="/images/branch-predictor/FSM-2bit-2.png">
<img alt="image" src="/images/branch-predictor/FSM-2bit-3.png"></p>
<p>再拓展开去，PHT的entry可以是任意位（bit）的saturating counter，counter的位数（width）越多，predictor的更新就越不敏感。
不过实际上不会用到太多bit，2 bit和3 bit是最常见的（例如Alpha 21264就用的是3-bit saturating counter）。
不过，也许你已经发现了，我们的saturating counter的初始值是有讲究的。上例用的是Weakly Not Taken，其实Weakly Taken也可以，但是如果初始值设为Strongly (Not) Taken，效果就不如人意了。这是因为一开始我们的predictor没有任何历史的信息，让saturating counter变得敏感一些有助于记住正确的pattern。saturating counter的位数越多，设为敏感值的优势越多。</p>
<p>回到SimpleScalar的source code，SimpleScalar所实现的正是上文所讲的2-bit saturating counter（即source code中的<code>BPred2bit</code>）。</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="cm">/* create a branch predictor */</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">bpred_t</span><span class="w"> </span><span class="o">*</span><span class="w">            </span><span class="cm">/* branch predictory instance */</span>
<span class="n">bpred_create</span><span class="p">(</span><span class="k">enum</span><span class="w"> </span><span class="n">bpred_class</span><span class="w"> </span><span class="n">class</span><span class="p">,</span><span class="w">    </span><span class="cm">/* type of predictor to create */</span>
<span class="w">         </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">bimod_size</span><span class="p">,</span><span class="w">   </span><span class="cm">/* bimod table size */</span>
<span class="w">         </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">l1size</span><span class="p">,</span><span class="w">   </span><span class="cm">/* 2lev l1 table size */</span>
<span class="w">         </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">l2size</span><span class="p">,</span><span class="w">   </span><span class="cm">/* 2lev l2 table size */</span>
<span class="w">         </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">meta_size</span><span class="p">,</span><span class="w">    </span><span class="cm">/* meta table size */</span>
<span class="w">         </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">shift_width</span><span class="p">,</span><span class="w">  </span><span class="cm">/* history register width */</span>
<span class="w">         </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">xor</span><span class="p">,</span><span class="w">      </span><span class="cm">/* history xor address flag */</span>
<span class="w">         </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">btb_sets</span><span class="p">,</span><span class="w"> </span><span class="cm">/* number of sets in BTB */</span><span class="w"> </span>
<span class="w">         </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">btb_assoc</span><span class="p">,</span><span class="w">    </span><span class="cm">/* BTB associativity */</span>
<span class="w">         </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">retstack_size</span><span class="p">)</span><span class="w"> </span><span class="cm">/* num entries in ret-addr stack */</span>
</code></pre></div></td></tr></table></div>

<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span>
<span class="normal">4</span>
<span class="normal">5</span>
<span class="normal">6</span>
<span class="normal">7</span>
<span class="normal">8</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="cm">/* create a branch direction predictor */</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">bpred_dir_t</span><span class="w"> </span><span class="o">*</span><span class="w">        </span><span class="cm">/* branch direction predictor instance */</span>
<span class="n">bpred_dir_create</span><span class="w"> </span><span class="p">(</span>
<span class="w">  </span><span class="k">enum</span><span class="w"> </span><span class="n">bpred_class</span><span class="w"> </span><span class="n">class</span><span class="p">,</span><span class="w">   </span><span class="cm">/* type of predictor to create */</span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">l1size</span><span class="p">,</span><span class="w">      </span><span class="cm">/* level-1 table size */</span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">l2size</span><span class="p">,</span><span class="w">      </span><span class="cm">/* level-2 table size (if relevant) */</span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">shift_width</span><span class="p">,</span><span class="w"> </span><span class="cm">/* history register width */</span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">xor</span><span class="p">)</span><span class="w">         </span><span class="cm">/* history xor address flag */</span>
</code></pre></div></td></tr></table></div>

<p>如前所述，SimpleScalar的branch direction predictor是一个<code>struct bpred_dir_t</code>，<code>BPred2bit</code>的结构定义就在<code>struct bpred_dir_t</code>中：</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span>
<span class="normal">4</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">size</span><span class="p">;</span><span class="w">    </span><span class="cm">/* number of entries in direct-mapped table */</span>
<span class="w">      </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">table</span><span class="p">;</span><span class="w"> </span><span class="cm">/* prediction state table */</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="n">bimod</span><span class="p">;</span>
</code></pre></div></td></tr></table></div>

<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="cm">/* direction predictor def */</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">bpred_dir_t</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">enum</span><span class="w"> </span><span class="n">bpred_class</span><span class="w"> </span><span class="n">class</span><span class="p">;</span><span class="w">   </span><span class="cm">/* type of predictor */</span>
<span class="w">  </span><span class="k">union</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">size</span><span class="p">;</span><span class="w">    </span><span class="cm">/* number of entries in direct-mapped table */</span>
<span class="w">      </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">table</span><span class="p">;</span><span class="w"> </span><span class="cm">/* prediction state table */</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="n">bimod</span><span class="p">;</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="kt">int</span><span class="w"> </span><span class="n">l1size</span><span class="p">;</span><span class="w">       </span><span class="cm">/* level-1 size, number of history regs */</span>
<span class="w">      </span><span class="kt">int</span><span class="w"> </span><span class="n">l2size</span><span class="p">;</span><span class="w">       </span><span class="cm">/* level-2 size, number of pred states */</span>
<span class="w">      </span><span class="kt">int</span><span class="w"> </span><span class="n">shift_width</span><span class="p">;</span><span class="w">      </span><span class="cm">/* amount of history in level-1 shift regs */</span>
<span class="w">      </span><span class="kt">int</span><span class="w"> </span><span class="n">xor</span><span class="p">;</span><span class="w">          </span><span class="cm">/* history xor address flag */</span>
<span class="w">      </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">shiftregs</span><span class="p">;</span><span class="w">       </span><span class="cm">/* level-1 history table */</span>
<span class="w">      </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">l2table</span><span class="p">;</span><span class="w">   </span><span class="cm">/* level-2 prediction state table */</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="n">two</span><span class="p">;</span>
<span class="w">  </span><span class="p">}</span><span class="w"> </span><span class="n">config</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></td></tr></table></div>

<p>其中代码注释中的prediction state table就是我们所说的PHT，size表示PHT的entries数目。</p>
<p>让我们先来看看<code>BPred2bit</code> predictor的初始化。首先<code>bpred_create</code>函数被调用来创建branch predictor（即<code>bpred_t</code>结构），在该函数中<code>bpred_dir_create</code>函数被调用来创建direction branch predictor部分（即<code>bpred_dir_t</code>结构），<code>BPred2bit</code>的初始化就在函数<code>bpred_dir_create</code>的以下几行代码中：</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="w">  </span><span class="k">struct</span><span class="w"> </span><span class="nc">bpred_dir_t</span><span class="w"> </span><span class="o">*</span><span class="n">pred_dir</span><span class="p">;</span>
<span class="w">  </span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">cnt</span><span class="p">;</span>
<span class="w">  </span><span class="kt">int</span><span class="w"> </span><span class="n">flipflop</span><span class="p">;</span>
<span class="w">  </span><span class="c1">// omit some code here...</span>
<span class="w">  </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">class</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">case</span><span class="w"> </span><span class="no">BPred2bit</span><span class="p">:</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">l1size</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="p">(</span><span class="n">l1size</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="p">(</span><span class="n">l1size</span><span class="mi">-1</span><span class="p">))</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">      </span><span class="n">fatal</span><span class="p">(</span><span class="s">&quot;2bit table size, `%d&#39;, must be non-zero and a power of two&quot;</span><span class="p">,</span><span class="w"> </span>
<span class="w">        </span><span class="n">l1size</span><span class="p">);</span>
<span class="w">    </span><span class="n">pred_dir</span><span class="o">-&gt;</span><span class="n">config</span><span class="p">.</span><span class="n">bimod</span><span class="p">.</span><span class="n">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">l1size</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">pred_dir</span><span class="o">-&gt;</span><span class="n">config</span><span class="p">.</span><span class="n">bimod</span><span class="p">.</span><span class="n">table</span><span class="w"> </span><span class="o">=</span>
<span class="w">      </span><span class="n">calloc</span><span class="p">(</span><span class="n">l1size</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span><span class="w"> </span><span class="kt">char</span><span class="p">))))</span>
<span class="w">      </span><span class="n">fatal</span><span class="p">(</span><span class="s">&quot;cannot allocate 2bit storage&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="cm">/* initialize counters to weakly this-or-that */</span>
<span class="w">    </span><span class="n">flipflop</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">cnt</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">cnt</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">l1size</span><span class="p">;</span><span class="w"> </span><span class="n">cnt</span><span class="o">++</span><span class="p">)</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">      </span><span class="n">pred_dir</span><span class="o">-&gt;</span><span class="n">config</span><span class="p">.</span><span class="n">bimod</span><span class="p">.</span><span class="n">table</span><span class="p">[</span><span class="n">cnt</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">flipflop</span><span class="p">;</span>
<span class="w">      </span><span class="n">flipflop</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">flipflop</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">break</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
</code></pre></div></td></tr></table></div>

<p>这段代码先检查PHT的entries数目（即代码中的<code>l1size</code>）是否合法——这个数目取决于用来做index的寄存器的位数（width），如果我们取PC的某$M$位作为index，则entries数目只能是$2^M$。
如果<code>l1size</code>合法，则为PHT分配空间。
接下来把PHT的每个entry都初始化为Weakly Not Taken（对于2-bit saturating counter来说就是1）。</p>
<!-- 
也就是branch应当为not taken时，我们的predictor仍然会预测 
-->

<p>(待续)</p>
<h4 id="correlated-branch-predictor">correlated branch predictor</h4>
<h4 id="2-level-branch-predictor">2-level branch predictor</h4>
<h4 id="gshare-branch-predictor">gshare branch predictor</h4>
<h4 id="hybrid-branch-predictor">hybrid branch predictor</h4>
<h2 id="_1">参考资料</h2>
<p>[1]<a href="http://www.hpl.hp.com/techreports/Compaq-DEC/WRL-TN-36.pdf">McFarling S. Combining branch predictors[R]. Technical Report TN-36, Digital Western Research Laboratory, 1993.</a></p>
      </div><!-- /.entry-content -->

    </article>
  </section>
                <section id="extras" class="body">
                                <div class="blogroll">
                                        <h2>links</h2>
                                        <ul>
                                                        <li><a href="http://getpelican.com/">Pelican</a></li>
                                                        <li><a href="http://python.org/">Python.org</a></li>
                                        </ul>
                                </div><!-- /.blogroll -->
                                <div class="social">
                                        <h2>social</h2>
                                        <ul>

                                                        <li><a href="https://github.com/yszheda">GitHub</a></li>
                                                        <li><a href="https://twitter.com/yszheda">Twitter</a></li>
                                        </ul>
                                </div><!-- /.social -->
                </section><!-- /#extras -->

                <footer id="contentinfo" class="body">
                        <address id="about" class="vcard body">
                                Proudly powered by <a rel="nofollow" href="https://getpelican.com/">Pelican</a>, which takes great advantage of <a rel="nofollow" href="https://www.python.org/">Python</a>.
                        </address><!-- /#about -->

                        <p>The theme is by <a rel="nofollow" href="https://www.smashingmagazine.com/2009/08/designing-a-html-5-layout-from-scratch/">Smashing Magazine</a>, thanks!</p>
                </footer><!-- /#contentinfo -->

        </body>
</html>