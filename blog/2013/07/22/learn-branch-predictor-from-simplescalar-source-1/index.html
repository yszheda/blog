
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Learn branch prediction from SimpleScalar source (1) - Galoisplusplus</title>
  <meta name="author" content="Galoisplusplus">

  
  <meta name="description" content="Introduce basic branch prediction concept using the source code of SimpleScalar">
  <meta name="keywords" content="Branch Prediction, SimpleScalar, Computer Architecture, 分支预测, 体系结构, 计算机体系">

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://yszheda.github.io/blog/blog/2013/07/22/learn-branch-predictor-from-simplescalar-source-1">
  <link href="/blog/favicon.png" rel="icon">
  <link href="/blog/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/blog/atom.xml" rel="alternate" title="Galoisplusplus" type="application/atom+xml">
  <script src="/blog/javascripts/modernizr-2.0.js"></script>
  <!--
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  -->
  <script src="//libs.baidu.com/jquery/1.7.2/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/lib/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/blog/javascripts/octopress.js" type="text/javascript"></script>
  
<!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<!--
<link href="http://fonts.googleapis.com/css?family=Crimson+Text:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
-->

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/blog/">Galoisplusplus</a></h1>
  
    <h2>A fan of science, technology and Classical music.</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/blog/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:yszheda.github.io/blog" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/blog/">Blog</a></li>
  <li><a href="/blog/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div>
<article class="hentry" role="article">
  
  <header>
    
      <h1 class="entry-title">Learn Branch Prediction From SimpleScalar Source (1)</h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-07-22T17:10:00+08:00" pubdate data-updated="true"></time>
        
      </p>
    
  </header>


<div class="entry-content"><p>作为一名CSer，最好的学习方式之一无疑是tracing code，看源代码——
不知你此时是否与我一样想起了Linus那句名言「talk is cheap, show me the <del>fucking</del> code!」?
可是对计算机体系结构来说，很多技术直接是由硬件实现的，因而也被蒙上一层神秘的面纱。
好在还有一些模拟器（simulator）软件，例如SimpleScalar(<a href="http://www.simplescalar.com/">http://www.simplescalar.com/</a>)就是这样一套模拟处理器性能的工具集。
之前我有幸通过做一些project接触SimpleScalar并读了一些cache技术的源代码。
在此我借SimpleScalar源代码为工具介绍branch prediction技术，
也算是对几个月前折腾时光的一种整理吧~</p>

<p>首先先简单介绍下branch prediction是做神马。
branch是instruction sets里面十分常见的一类指令。
一般可以分为：</p>

<ul>
<li><p>conditional branch：只在某条件下才跳转。例如<code>MIPS</code>里的<code>beq</code>/<code>bne</code>等。</p></li>
<li><p>unconditional branch（或简称jump）: 无条件跳转。例如<code>MIPS</code>里的<code>j</code>/<code>jr</code>等。</p></li>
<li><p>还有一类特殊的跳转指令，就是function call和return。</p></li>
</ul>


<!-- more -->


<p>这类指令在一般程序里的出现频率是很高的，据说平均每4至5条指令就会出现一条branch指令，这也是为什么大多数<code>basic block</code>都很短的原因。
不幸的是，在我们CPU的pipeline中我们常常要在后面的stage才能得到branch的结果。
显然在fetch到branch指令与resolve出结果之间「漫长」的clock cycle中，我们希望能同时处理之后的指令。
那么在resolve之前我们怎么知道branch之后的指令是什么？
这时候我们就需要branch prediction了。</p>

<p>简单地说，branch prediction要预测的主要是两件事：</p>

<ul>
<li><p>direction：conditional branch是taken还是not taken？</p></li>
<li><p>target：branch指令要跳转的目的地是哪里？除了conditional branch，这也包括function pointer和indirect jump，例如<code>MPIS</code>中的<code>jr</code>指令就需要在计算出<code>r31</code>的值后才知道跳转目标。</p></li>
</ul>


<p>针对预测direction的有branch direction predictor；
针对预测target的有一般的BTB(Branch Target Buffer)，
还有针对call和return的RAS(Return Address Stack)。
在SimpleScalar中，branch predictor被定义为以下structure：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cm">/* branch predictor def */</span>
</span><span class='line'><span class="k">struct</span> <span class="kt">bpred_t</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">enum</span> <span class="n">bpred_class</span> <span class="n">class</span><span class="p">;</span> <span class="cm">/* type of predictor */</span>
</span><span class='line'>  <span class="k">struct</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">struct</span> <span class="kt">bpred_dir_t</span> <span class="o">*</span><span class="n">bimod</span><span class="p">;</span>      <span class="cm">/* first direction predictor */</span>
</span><span class='line'>    <span class="k">struct</span> <span class="kt">bpred_dir_t</span> <span class="o">*</span><span class="n">twolev</span><span class="p">;</span>     <span class="cm">/* second direction predictor */</span>
</span><span class='line'>    <span class="k">struct</span> <span class="kt">bpred_dir_t</span> <span class="o">*</span><span class="n">meta</span><span class="p">;</span>   <span class="cm">/* meta predictor */</span>
</span><span class='line'>  <span class="p">}</span> <span class="n">dirpred</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">struct</span> <span class="p">{</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">sets</span><span class="p">;</span>           <span class="cm">/* num BTB sets */</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">assoc</span><span class="p">;</span>          <span class="cm">/* BTB associativity */</span>
</span><span class='line'>    <span class="k">struct</span> <span class="kt">bpred_btb_ent_t</span> <span class="o">*</span><span class="n">btb_data</span><span class="p">;</span> <span class="cm">/* BTB addr-prediction table */</span>
</span><span class='line'>  <span class="p">}</span> <span class="n">btb</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">struct</span> <span class="p">{</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">size</span><span class="p">;</span>           <span class="cm">/* return-address stack size */</span>
</span><span class='line'>    <span class="kt">int</span> <span class="n">tos</span><span class="p">;</span>            <span class="cm">/* top-of-stack */</span>
</span><span class='line'>    <span class="k">struct</span> <span class="kt">bpred_btb_ent_t</span> <span class="o">*</span><span class="n">stack</span><span class="p">;</span> <span class="cm">/* return-address stack */</span>
</span><span class='line'>  <span class="p">}</span> <span class="n">retstack</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// 以下省略模拟用的状态计数器</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>以下我将针对各部分进行介绍。</p>

<h2>branch direction predictor</h2>

<p>在SimpleScalar中定义了如下的direction predictor类别：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cm">/* branch predictor types */</span>
</span><span class='line'><span class="k">enum</span> <span class="n">bpred_class</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">BPredComb</span><span class="p">,</span>            <span class="cm">/* combined predictor (McFarling) */</span>
</span><span class='line'>  <span class="n">BPred2Level</span><span class="p">,</span>          <span class="cm">/* 2-level correlating pred w/2-bit counters */</span>
</span><span class='line'>  <span class="n">BPred2bit</span><span class="p">,</span>            <span class="cm">/* 2-bit saturating cntr pred (dir mapped) */</span>
</span><span class='line'>  <span class="n">BPredTaken</span><span class="p">,</span>           <span class="cm">/* static predict taken */</span>
</span><span class='line'>  <span class="n">BPredNotTaken</span><span class="p">,</span>        <span class="cm">/* static predict not taken */</span>
</span><span class='line'>  <span class="n">BPred_NUM</span>
</span></code></pre></td></tr></table></div></figure>


<p>其中最后一项<code>BPred_NUM</code>只是取巧利用c语言中enum的性质得到predictor种类数目罢了（在c中enum的成员是可以被转化为int类型的，这在强调type safe的c++眼中当然很邪恶，为此c++还有enum class来杜绝这种事），<code>BPredTaken</code>和<code>BPredNotTaken</code>都属于static prediction，
除此之外的前面三个属于dynamic prediction。</p>

<h3>static branch prediction</h3>

<p>static branch prediction无疑是最naive的direction predictor，不考虑程序runtime执行的动态信息，只根据当前看到的branch指令来做预测。
SimpleScalar采用了其中最简单的两种策略：</p>

<ul>
<li><p>always taken：总是预测branch不会跳转。</p></li>
<li><p>always not taken：总是预测branch会跳转。</p></li>
</ul>


<p>当然这二者预测的准确率就纯靠人品了。
还有稍微高级点的static branch predictor：</p>

<ul>
<li>根据branch target和当前branch指令的pc之间的offset来决定。
如果target在branch指令之前则预测跳转，
如果target在branch指令之后则预测不跳转（backward taken, forward not taken）。
这样的策略是基于程序中常常出现的loop结构，在loop中branch的target通常是backward的。
例如以下这段C代码</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">100</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="p">...</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>被翻译成类似下面的汇编代码：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">addi</span> <span class="n">r1</span><span class="p">,</span> <span class="n">r0</span><span class="p">,</span> <span class="mi">0</span>
</span><span class='line'><span class="n">addi</span> <span class="n">r2</span><span class="p">,</span> <span class="n">r0</span><span class="p">,</span> <span class="mi">100</span>
</span><span class='line'><span class="nl">Lable_loop</span><span class="p">:</span> <span class="p">...</span>
</span><span class='line'><span class="n">addi</span> <span class="n">r1</span><span class="p">,</span> <span class="n">r1</span><span class="p">,</span> <span class="mi">1</span>
</span><span class='line'><span class="n">bne</span> <span class="n">r1</span><span class="p">,</span> <span class="n">r2</span><span class="p">,</span> <span class="n">Lable_loop</span>
</span></code></pre></td></tr></table></div></figure>


<p>如果采用backward taken，则这个loop跑一遍只有最后一次是预测错误，前面九十九次都对了，这就提高了loop结构branch的预测准确率。</p>

<ul>
<li>根据compiler的提示。一般是通过状态寄存器（status register，例如x86体系架构的FLAGS寄存器）来标记branch direction的结果。
（这种策略是把control dependency转化为data dependency。）</li>
</ul>


<h3>dynamic branch prediction</h3>

<h4>counter predictor</h4>

<!--
最简单的dynamic branch predictor是counter-based predictor。
这种predictor的想法很简单，只要维护有关branch指令跳转与不跳转的历史，下次再遇到同一条指令时就可以根据该历史来做预测了。
-->


<p>这种predictor的原始想法其实很简单，只要维护有关branch指令跳转与不跳转的历史，下次再遇到同一条指令时就可以根据该历史来做预测了。</p>

<p>一般用来存放跳转历史的数据结构是hash table，
hash table的index是以branch指令的PC（Program Counter）的hash值，
那么hash table的entry应该存什么呢？
最简单的想法就是保存该branch指令上一次是taken还是not taken的信息，显然这样的entry只需一个bit就够了。
当下次再遇到这条branch指令时，我们预测跳转的行为跟其历史是一致的。
我们可以认为hash table存放了供预测用的pattern，所以习惯上也把这张表称为PHT（Pattern History Table）。</p>

<p>还是以类似前面那段for循环的代码为例子，为了便于解释我把循环次数减少到5：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="p">...</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>可以被翻译成如下汇编代码：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">addi</span> <span class="n">r1</span><span class="p">,</span> <span class="n">r0</span><span class="p">,</span> <span class="mi">0</span>
</span><span class='line'><span class="n">addi</span> <span class="n">r2</span><span class="p">,</span> <span class="n">r0</span><span class="p">,</span> <span class="mi">5</span>
</span><span class='line'><span class="nl">Lable_loop</span><span class="p">:</span> <span class="p">...</span>
</span><span class='line'><span class="n">addi</span> <span class="n">r1</span><span class="p">,</span> <span class="n">r1</span><span class="p">,</span> <span class="mi">1</span>
</span><span class='line'><span class="n">bne</span> <span class="n">r1</span><span class="p">,</span> <span class="n">r2</span><span class="p">,</span> <span class="n">Lable_loop</span>
</span></code></pre></td></tr></table></div></figure>


<p>假设branch的跳转历史初始为Not Taken，则跑一遍上述for循环遇到bne指令的情况如下表：</p>

<table border="1" table-layout:fixed>
    <tr>
        <td> r1的值 </td>
        <td> 1 </td>
        <td> 2 </td>
        <td> 3 </td>
        <td> 4 </td>
        <td> 5 </td>
    </tr>
    <tr>
        <td> branch历史 </td>
        <td> Not Taken </td>
        <td> Taken </td>
        <td> Taken </td>
        <td> Taken </td>
        <td> Taken </td>
    </tr>
    <tr>
        <td> 预测 </td>
        <td> Not Taken </td>
        <td> Taken </td>
        <td> Taken </td>
        <td> Taken </td>
        <td> Taken </td>
    </tr>
    <tr>
        <td> 实际情况 </td>
        <td> Taken </td>
        <td> Taken </td>
        <td> Taken </td>
        <td> Taken </td>
        <td> Not Taken </td>
    </tr>
    <tr>
        <td> 正确性 </td>
        <td> 错误 </td>
        <td> 正确 </td>
        <td> 正确 </td>
        <td> 正确 </td>
        <td> 错误 </td>
    </tr>
</table>


<p>于是跑完这个loop一遍的正确率为60%。</p>

<p>这个保存branch上一次是taken还是not taken的entry经常由一个1-bit saturating counter来实现，
这里的saturating是说当counter达到上限（对于1-bit的counter来说是1）时就不再递增，达到下限（对于1-bit的counter来说是0）时就不再递减。
（这也是为什么这种策略被称为counter-based，后面可以看到这也是一种可被拓展的做法。）
对于这种counter-based的实现方法来说，我们要解决的最关键问题是：</p>

<ul>
<li><p>如何根据实际的跳转来更新counter？</p></li>
<li><p>如何根据counter来预测下一次跳转？</p></li>
</ul>


<p>假设我们的1-bit saturating counter为1时代表taken，为0时代表not taken，则我们可以这样回答上面两个问题：</p>

<ul>
<li><p>counter每遇到实际是taken的情况就做递增，反之则做递减。</p></li>
<li><p>如果counter的值为1，则预测下次是taken，否则，预测下次是not taken。</p></li>
</ul>


<p>不难看出，这样的1-bit saturating counter忠实地模拟了我们之前所用的”branch历史“的行为。
整个方法的原理图如下图所示：</p>

<p><img src="/blog/images/branch-predictor/bimodal.png"></p>

<p>另外，当我们审视1-bit saturating counter的update logic，我们会发现counter的更新值（新的状态）取决于counter的旧值（旧的状态）和当前branch实际的跳转情况（输入），这是一个finite-state Moore machine：</p>

<p><img src="/blog/images/branch-predictor/FSM-LT.png"></p>

<p>接下来让我们来看看1-bit saturating counter会有什么问题。
假设我们之前例子中的循环体会被执行不止一次——这也是很常见的情况，例如在嵌套循环（nested loop）当中：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="p">...</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>可以被翻译成如下汇编代码：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="n">addi</span> <span class="n">r3</span><span class="p">,</span> <span class="n">r0</span><span class="p">,</span> <span class="mi">0</span>
</span><span class='line'><span class="n">addi</span> <span class="n">r4</span><span class="p">,</span> <span class="n">r0</span><span class="p">,</span> <span class="mi">2</span>
</span><span class='line'><span class="nl">Outer_loop</span><span class="p">:</span>    
</span><span class='line'>  <span class="n">addi</span> <span class="n">r1</span><span class="p">,</span> <span class="n">r0</span><span class="p">,</span> <span class="mi">0</span>
</span><span class='line'>  <span class="n">addi</span> <span class="n">r2</span><span class="p">,</span> <span class="n">r0</span><span class="p">,</span> <span class="mi">5</span>
</span><span class='line'><span class="nl">Inner_loop</span><span class="p">:</span> <span class="p">...</span>
</span><span class='line'>  <span class="n">addi</span> <span class="n">r1</span><span class="p">,</span> <span class="n">r1</span><span class="p">,</span> <span class="mi">1</span>
</span><span class='line'>  <span class="n">bne</span> <span class="n">r1</span><span class="p">,</span> <span class="n">r2</span><span class="p">,</span> <span class="n">Inner_loop</span>
</span><span class='line'><span class="n">addi</span> <span class="n">r3</span><span class="p">,</span> <span class="n">r3</span><span class="p">,</span> <span class="mi">1</span>
</span><span class='line'><span class="n">bne</span> <span class="n">r3</span><span class="p">,</span> <span class="n">r4</span><span class="p">,</span> <span class="n">Outer_loop</span>
</span></code></pre></td></tr></table></div></figure>


<p>假设<code>bne r1, r2, Inner_loop</code>这条指令的跳转历史初始为Not Taken，同样跑一遍上述for循环遇到<code>bne r1, r2, Inner_loop</code>指令的情况如下表：</p>

<table border="1" table-layout:fixed>
    <tr>
        <td> r1的值 </td>
        <td> 1 </td>
        <td> 2 </td>
        <td> 3 </td>
        <td> 4 </td>
        <td> 5 </td>
        <td> 1 </td>
        <td> 2 </td>
        <td> 3 </td>
        <td> 4 </td>
        <td> 5 </td>
    </tr>
    <tr>
        <td> counter </td>
        <td> 0 </td>
        <td> 1 </td>
        <td> 1 </td>
        <td> 1 </td>
        <td> 1 </td>
        <td> 0 </td>
        <td> 1 </td>
        <td> 1 </td>
        <td> 1 </td>
        <td> 1 </td>
    </tr>
    <tr>
        <td> 预测 </td>
        <td> Not Taken </td>
        <td> Taken </td>
        <td> Taken </td>
        <td> Taken </td>
        <td> Taken </td>
        <td> Not Taken </td>
        <td> Taken </td>
        <td> Taken </td>
        <td> Taken </td>
        <td> Taken </td>
    </tr>
    <tr>
        <td> 实际情况 </td>
        <td> Taken </td>
        <td> Taken </td>
        <td> Taken </td>
        <td> Taken </td>
        <td> Not Taken </td>
        <td> Taken </td>
        <td> Taken </td>
        <td> Taken </td>
        <td> Taken </td>
        <td> Not Taken </td>
    </tr>
    <tr>
        <td> 正确性 </td>
        <td> 错误 </td>
        <td> 正确 </td>
        <td> 正确 </td>
        <td> 正确 </td>
        <td> 错误 </td>
        <td> 错误 </td>
        <td> 正确 </td>
        <td> 正确 </td>
        <td> 正确 </td>
        <td> 错误 </td>
    </tr>
</table>


<p>通过分析它的行为我们可以发现，由于该counter只根据上一次跳转的行为来做预测，所以在最后跳出循环后，我们的counter立即记下是not taken，这样在下次进入该循环体后我们就只能预测not taken，而一般第一次执行循环体都应该是taken，故而我们的predictor在这种naive的情况下还是mispredict了，那么该如何解决这个问题呢？
解决方案就是在预测时不止看一次历史跳转，而是综合多次历史记录。换言之，让我们的PHT entry不那么敏感（sensitive）。
最简单的一种拓展方式就是每个entry增加一个bit，成为一个2-bit saturating counter。
同样，我们不能避开那两个问题，以下是一种解答：</p>

<ul>
<li><p>counter每遇到实际是taken的情况就做递增，反之则做递减。</p></li>
<li><p>如果counter最高位（MSB）的值为1，则预测下次是taken，否则，预测下次是not taken。
我们可以相应地把2-bit saturating counter的值解释为：</p></li>
</ul>


<table>
    <header>
        <tr>
            <th>counter值</th>
            <th>含义</th>
        </tr>
    </header>
    <body>
        <tr>
            <td>00</td>
            <td>Strongly Not Taken</td>
        </tr>
        <tr>
            <td>01</td>
            <td>Weakly Not Taken</td>
        </tr>
        <tr>
            <td>10</td>
            <td>Weakly Taken</td>
        </tr>
        <tr>
            <td>11</td>
            <td>Strongly Taken</td>
        </tr>
    </body>
</table>


<p>这时我们的finite state machine就如下图：</p>

<p><img src="/blog/images/branch-predictor/FSM-2bit-0.png"></p>

<p>再跑一遍之前的例子。
假设<code>bne r1, r2, Inner_loop</code>这条指令的跳转历史初始为Weakly Not Taken，同样跑一遍上述for循环遇到<code>bne r1, r2, Inner_loop</code>指令的情况如下表：</p>

<table border="1" table-layout:fixed>
    <tr>
        <td> r1的值 </td>
        <td> 1 </td>
        <td> 2 </td>
        <td> 3 </td>
        <td> 4 </td>
        <td> 5 </td>
        <td> 1 </td>
        <td> 2 </td>
        <td> 3 </td>
        <td> 4 </td>
        <td> 5 </td>
    </tr>
    <tr>
        <td> counter </td>
        <td> 01 </td>
        <td> 10 </td>
        <td> 11 </td>
        <td> 11 </td>
        <td> 11 </td>
        <td> 10 </td>
        <td> 11 </td>
        <td> 11 </td>
        <td> 11 </td>
        <td> 10 </td>
    </tr>
    <tr>
        <td> 预测 </td>
        <td> Not Taken </td>
        <td> Taken </td>
        <td> Taken </td>
        <td> Taken </td>
        <td> Taken </td>
        <td> Not Taken </td>
        <td> Taken </td>
        <td> Taken </td>
        <td> Taken </td>
        <td> Taken </td>
    </tr>
    <tr>
        <td> 实际情况 </td>
        <td> Taken </td>
        <td> Taken </td>
        <td> Taken </td>
        <td> Taken </td>
        <td> Not Taken </td>
        <td> Taken </td>
        <td> Taken </td>
        <td> Taken </td>
        <td> Taken </td>
        <td> Not Taken </td>
    </tr>
    <tr>
        <td> 正确性 </td>
        <td> 错误 </td>
        <td> 正确 </td>
        <td> 正确 </td>
        <td> 正确 </td>
        <td> 错误 </td>
        <td> 正确 </td>
        <td> 正确 </td>
        <td> 正确 </td>
        <td> 正确 </td>
        <td> 错误 </td>
    </tr>
</table>


<p>不难看出，由于2-bit saturating counter正确地处理了1-bit saturating counter在再次进入循环体的预测错误，使得正确率从60%提升到了70%。</p>

<p>值得一提的是，用2-bit counter来实现并非只有上述方法。以下这几种FSM同样可以，例如采用第一个FSM的话，则连续发生两次Not Taken时就设为Strongly Not Taken。</p>

<p><img src="/blog/images/branch-predictor/FSM-2bit-1.png">
<img src="/blog/images/branch-predictor/FSM-2bit-2.png">
<img src="/blog/images/branch-predictor/FSM-2bit-3.png"></p>

<p>再拓展开去，PHT的entry可以是任意位（bit）的saturating counter，counter的位数（width）越多，predictor的更新就越不敏感。
不过实际上不会用到太多bit，2 bit和3 bit是最常见的（例如Alpha 21264就用的是3-bit saturating counter）。
不过，也许你已经发现了，我们的saturating counter的初始值是有讲究的。上例用的是Weakly Not Taken，其实Weakly Taken也可以，但是如果初始值设为Strongly (Not) Taken，效果就不如人意了。这是因为一开始我们的predictor没有任何历史的信息，让saturating counter变得敏感一些有助于记住正确的pattern。saturating counter的位数越多，设为敏感值的优势越多。</p>

<p>回到SimpleScalar的source code，SimpleScalar所实现的正是上文所讲的2-bit saturating counter（即source code中的<code>BPred2bit</code>）。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cm">/* create a branch predictor */</span>
</span><span class='line'><span class="k">struct</span> <span class="kt">bpred_t</span> <span class="o">*</span>            <span class="cm">/* branch predictory instance */</span>
</span><span class='line'><span class="n">bpred_create</span><span class="p">(</span><span class="k">enum</span> <span class="n">bpred_class</span> <span class="n">class</span><span class="p">,</span>    <span class="cm">/* type of predictor to create */</span>
</span><span class='line'>       <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bimod_size</span><span class="p">,</span> <span class="cm">/* bimod table size */</span>
</span><span class='line'>       <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">l1size</span><span class="p">,</span> <span class="cm">/* 2lev l1 table size */</span>
</span><span class='line'>       <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">l2size</span><span class="p">,</span> <span class="cm">/* 2lev l2 table size */</span>
</span><span class='line'>       <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">meta_size</span><span class="p">,</span>  <span class="cm">/* meta table size */</span>
</span><span class='line'>       <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">shift_width</span><span class="p">,</span>    <span class="cm">/* history register width */</span>
</span><span class='line'>       <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">xor</span><span class="p">,</span>    <span class="cm">/* history xor address flag */</span>
</span><span class='line'>       <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">btb_sets</span><span class="p">,</span>   <span class="cm">/* number of sets in BTB */</span>
</span><span class='line'>       <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">btb_assoc</span><span class="p">,</span>  <span class="cm">/* BTB associativity */</span>
</span><span class='line'>       <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">retstack_size</span><span class="p">)</span> <span class="cm">/* num entries in ret-addr stack */</span>
</span></code></pre></td></tr></table></div></figure>




<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cm">/* create a branch direction predictor */</span>
</span><span class='line'><span class="k">struct</span> <span class="kt">bpred_dir_t</span> <span class="o">*</span>        <span class="cm">/* branch direction predictor instance */</span>
</span><span class='line'><span class="n">bpred_dir_create</span> <span class="p">(</span>
</span><span class='line'>  <span class="k">enum</span> <span class="n">bpred_class</span> <span class="n">class</span><span class="p">,</span> <span class="cm">/* type of predictor to create */</span>
</span><span class='line'>  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">l1size</span><span class="p">,</span>      <span class="cm">/* level-1 table size */</span>
</span><span class='line'>  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">l2size</span><span class="p">,</span>      <span class="cm">/* level-2 table size (if relevant) */</span>
</span><span class='line'>  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">shift_width</span><span class="p">,</span> <span class="cm">/* history register width */</span>
</span><span class='line'>  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">xor</span><span class="p">)</span>         <span class="cm">/* history xor address flag */</span>
</span></code></pre></td></tr></table></div></figure>


<p>如前所述，SimpleScalar的branch direction predictor是一个<code>struct bpred_dir_t</code>，<code>BPred2bit</code>的结构定义就在<code>struct bpred_dir_t</code>中：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="k">struct</span> <span class="p">{</span>
</span><span class='line'>  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">size</span><span class="p">;</span>    <span class="cm">/* number of entries in direct-mapped table */</span>
</span><span class='line'>  <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">table</span><span class="p">;</span>  <span class="cm">/* prediction state table */</span>
</span><span class='line'><span class="p">}</span> <span class="n">bimod</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'><span class="cm">/* direction predictor def */</span>
</span><span class='line'><span class="k">struct</span> <span class="kt">bpred_dir_t</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">enum</span> <span class="n">bpred_class</span> <span class="n">class</span><span class="p">;</span> <span class="cm">/* type of predictor */</span>
</span><span class='line'>  <span class="k">union</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">struct</span> <span class="p">{</span>
</span><span class='line'>      <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">size</span><span class="p">;</span>    <span class="cm">/* number of entries in direct-mapped table */</span>
</span><span class='line'>      <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">table</span><span class="p">;</span>  <span class="cm">/* prediction state table */</span>
</span><span class='line'>    <span class="p">}</span> <span class="n">bimod</span><span class="p">;</span>
</span><span class='line'>    <span class="k">struct</span> <span class="p">{</span>
</span><span class='line'>      <span class="kt">int</span> <span class="n">l1size</span><span class="p">;</span>       <span class="cm">/* level-1 size, number of history regs */</span>
</span><span class='line'>      <span class="kt">int</span> <span class="n">l2size</span><span class="p">;</span>       <span class="cm">/* level-2 size, number of pred states */</span>
</span><span class='line'>      <span class="kt">int</span> <span class="n">shift_width</span><span class="p">;</span>      <span class="cm">/* amount of history in level-1 shift regs */</span>
</span><span class='line'>      <span class="kt">int</span> <span class="n">xor</span><span class="p">;</span>          <span class="cm">/* history xor address flag */</span>
</span><span class='line'>      <span class="kt">int</span> <span class="o">*</span><span class="n">shiftregs</span><span class="p">;</span>        <span class="cm">/* level-1 history table */</span>
</span><span class='line'>      <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">l2table</span><span class="p">;</span>    <span class="cm">/* level-2 prediction state table */</span>
</span><span class='line'>    <span class="p">}</span> <span class="n">two</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span> <span class="n">config</span><span class="p">;</span>
</span><span class='line'><span class="p">};</span>
</span></code></pre></td></tr></table></div></figure>


<p>其中代码注释中的prediction state table就是我们所说的PHT，size表示PHT的entries数目。</p>

<p>让我们先来看看<code>BPred2bit</code> predictor的初始化。首先<code>bpred_create</code>函数被调用来创建branch predictor（即<code>bpred_t</code>结构），在该函数中<code>bpred_dir_create</code>函数被调用来创建direction branch predictor部分（即<code>bpred_dir_t</code>结构），<code>BPred2bit</code>的初始化就在函数<code>bpred_dir_create</code>的以下几行代码中：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class='c'><span class='line'>  <span class="k">struct</span> <span class="kt">bpred_dir_t</span> <span class="o">*</span><span class="n">pred_dir</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cnt</span><span class="p">;</span>
</span><span class='line'>  <span class="kt">int</span> <span class="n">flipflop</span><span class="p">;</span>
</span><span class='line'>  <span class="c1">// omit some code here...</span>
</span><span class='line'>  <span class="k">switch</span> <span class="p">(</span><span class="n">class</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">case</span> <span class="nl">BPred2bit</span><span class="p">:</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">l1size</span> <span class="o">||</span> <span class="p">(</span><span class="n">l1size</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">l1size</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
</span><span class='line'>      <span class="n">fatal</span><span class="p">(</span><span class="s">&quot;2bit table size, `%d&#39;, must be non-zero and a power of two&quot;</span><span class="p">,</span>
</span><span class='line'>      <span class="n">l1size</span><span class="p">);</span>
</span><span class='line'>    <span class="n">pred_dir</span><span class="o">-&gt;</span><span class="n">config</span><span class="p">.</span><span class="n">bimod</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="n">l1size</span><span class="p">;</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">pred_dir</span><span class="o">-&gt;</span><span class="n">config</span><span class="p">.</span><span class="n">bimod</span><span class="p">.</span><span class="n">table</span> <span class="o">=</span>
</span><span class='line'>    <span class="n">calloc</span><span class="p">(</span><span class="n">l1size</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">))))</span>
</span><span class='line'>      <span class="n">fatal</span><span class="p">(</span><span class="s">&quot;cannot allocate 2bit storage&quot;</span><span class="p">);</span>
</span><span class='line'>    <span class="cm">/* initialize counters to weakly this-or-that */</span>
</span><span class='line'>    <span class="n">flipflop</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'>    <span class="k">for</span> <span class="p">(</span><span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">cnt</span> <span class="o">&lt;</span> <span class="n">l1size</span><span class="p">;</span> <span class="n">cnt</span><span class="o">++</span><span class="p">)</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>    <span class="n">pred_dir</span><span class="o">-&gt;</span><span class="n">config</span><span class="p">.</span><span class="n">bimod</span><span class="p">.</span><span class="n">table</span><span class="p">[</span><span class="n">cnt</span><span class="p">]</span> <span class="o">=</span> <span class="n">flipflop</span><span class="p">;</span>
</span><span class='line'>    <span class="n">flipflop</span> <span class="o">=</span> <span class="mi">3</span> <span class="o">-</span> <span class="n">flipflop</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">break</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这段代码先检查PHT的entries数目（即代码中的<code>l1size</code>）是否合法——这个数目取决于用来做index的寄存器的位数（width），如果我们取PC的某$M$位作为index，则entries数目只能是$2<sup>M</sup>$。
如果<code>l1size</code>合法，则为PHT分配空间。
接下来把PHT的每个entry都初始化为Weakly Not Taken（对于2-bit saturating counter来说就是1）。</p>

<!-- 
也就是branch应当为not taken时，我们的predictor仍然会预测 
-->


<p>(待续)</p>

<h4>correlated branch predictor</h4>

<h4>2-level branch predictor</h4>

<h4>gshare branch predictor</h4>

<h4>hybrid branch predictor</h4>

<h2>参考资料</h2>

<p>[1]<a href="http://www.hpl.hp.com/techreports/Compaq-DEC/WRL-TN-36.pdf">McFarling S. Combining branch predictors[R]. Technical Report TN-36, Digital Western Research Laboratory, 1993.</a></p>
</div>


  <footer>
    <p class="meta">
      
  

<span class="byline author vcard">Posted by <span class="fn">Galoisplusplus</span></span>

      








  


<time datetime="2013-07-22T17:10:00+08:00" pubdate data-updated="true"></time>
      

<span class="categories">
  
    <a class='category' href='/blog/blog/categories/cs/'>cs</a>, <a class='category' href='/blog/blog/categories/tech/'>tech</a>
  
</span>


    </p>
    
      <div class="sharing">
  
  <a href="http://twitter.com/share" class="twitter-share-button" data-url="http://yszheda.github.io/blog/blog/2013/07/22/learn-branch-predictor-from-simplescalar-source-1/" data-via="" data-counturl="http://yszheda.github.io/blog/blog/2013/07/22/learn-branch-predictor-from-simplescalar-source-1/" >Tweet</a>
  
  
  
</div>

    
    <p class="meta">
      
        <a class="basic-alignment left" href="/blog/blog/2013/06/08/mpi-debug-tips/" title="Previous Post: MPI Debug Tips">&laquo; MPI Debug Tips</a>
      
      
        <a class="basic-alignment right" href="/blog/blog/2013/09/19/have-fun-with-vim-wiki/" title="Next Post: have fun with vim wiki">have fun with vim wiki &raquo;</a>
      
    </p>
  </footer>
</article>

</div>

<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/blog/2019/04/07/macbeth-by-tang-shu-wing/">《麦克白》的布莱希特剧场实践</a>
      </li>
    
      <li class="post">
        <a href="/blog/blog/2019/01/01/those-concerts-in-2018/">盘点2018年度的现场音乐会</a>
      </li>
    
      <li class="post">
        <a href="/blog/blog/2018/05/22/cudaErrorCudartUnloading/">cudaErrorCudartUnloading问题排查及建议方案</a>
      </li>
    
      <li class="post">
        <a href="/blog/blog/2018/01/01/those-concerts-in-2017/">盘点2017年度的现场音乐会</a>
      </li>
    
      <li class="post">
        <a href="/blog/blog/2017/11/11/Jonas-Kaufmann-recital/">Jonas Kaufmann独奏会之艺术歌曲</a>
      </li>
    
  </ul>
</section>





  
</aside>


    </div>
  </div>
  <footer role="contentinfo"><p>
<!--
Copyright &copy; 2020 - Galoisplusplus -
-->
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  


</body>
</html>
